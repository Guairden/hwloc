 \hypertarget{a00394_faq1}{}\section{Concepts}\label{a00394_faq1}
\hypertarget{a00394_faq_why}{}\subsection{I only need binding, why should I use hwloc ?}\label{a00394_faq_why}
hwloc is its portable A\+PI that works on a variety of operating systems. It supports binding of threads, processes and memory buffers (see \hyperlink{a00190}{C\+PU binding} and \hyperlink{a00191}{Memory binding}). Even if some features are not supported on some systems, using hwloc is much easier than reimplementing your own portability layer.

Moreover, hwloc provides knowledge of cores and hardware threads. It offers easy ways to bind tasks to individual hardware threads, or to entire multithreaded cores, etc. See \hyperlink{a00394_faq_smt}{How may I ignore symmetric multithreading, hyper-\/threading, etc. in hwloc?}. Most alternative software for binding do not even know whether each core is single-\/threaded, multithreaded or hyper-\/threaded. They would bind to individual threads without any way to know whether multiple tasks are in the same physical core.

However, using hwloc comes with an overhead since a topology must be loaded before gathering information and binding tasks or memory. Fortunately this overhead may be significantly reduced by filtering non-\/interesting information out of the topology. For instance the following code builds a topology that only contains Cores (explicitly filtered-\/in below), hardware threads (P\+Us, cannot be filtered-\/out), N\+U\+MA nodes (cannot be filtered-\/out), and the root object (usually a Machine; the root cannot be removed without breaking the tree).

\begin{DoxyVerb}hwloc_topology_t topology;
hwloc_topology_init(&topology);
/* filter everything out */
hwloc_topology_set_all_types_filter(topology, HWLOC_TYPE_FILTER_KEEP_NONE);
/* filter Cores back in */
hwloc_topology_set_type_filter(topology, HWLOC_OBJ_CORE, HWLOC_TYPE_FILTER_KEEP_ALL);
hwloc_topology_load(topology);
\end{DoxyVerb}


However, one should remember that filtering such objects out removes locality information from the hwloc tree. For instance, we do not know anymore which PU is close to which N\+U\+MA node. This would be useful to applications that explicitly want to place specific memory buffers close to specific tasks. Those applications just need to tell hwloc to keep Group objects that bring structure information\+: \begin{DoxyVerb}hwloc_topology_set_type_filter(topology, HWLOC_OBJ_GROUP, HWLOC_TYPE_FILTER_KEEP_STRUCTURE);
\end{DoxyVerb}


Note that the default configuration is to keep all objects enabled, except I/\+Os and instruction caches.\hypertarget{a00394_faq_indexes}{}\subsection{Should I use logical or physical/\+O\+S indexes? and how?}\label{a00394_faq_indexes}
One of the original reasons why hwloc was created is that {\bfseries physical/\+OS indexes} ({\ttfamily obj-\/$>$os\+\_\+index}) are often crazy and unpredictable\+: processors numbers are usually non-\/contiguous (processors 0 and 1 are not physically close), they vary from one machine to another, and may even change after a B\+I\+OS or system update. This numbers make task placement hardly portable. Moreover some objects have no physical/\+OS numbers (caches), and some objects have non-\/unique numbers (core numbers are only unique within a socket). Physical/\+OS indexes are only guaranteed to exist and be unique for PU and N\+U\+MA nodes.

hwloc therefore introduces {\bfseries logical indexes} ({\ttfamily obj-\/$>$logical\+\_\+index}) which are portable, contiguous and logically ordered (based on the resource organization in the locality tree). In general, one should only use logical indexes and just let hwloc do the internal conversion when really needed (when talking to the OS and hardware).

hwloc developers recommends that users do not use physical/\+OS indexes unless they really know what they are doing. The main reason for still using physical/\+OS indexes is when interacting with non-\/hwloc tools such as numactl or taskset, or when reading hardware information from raw sources such as /proc/cpuinfo.

lstopo options {\ttfamily -\/l} and {\ttfamily -\/p} may be used to switch between logical indexes (prefixed with {\ttfamily L\#}) and physical/\+OS indexes ({\ttfamily P\#}). Converting one into the other may also be achieved with hwloc-\/calc which may manipulate either logical or physical indexes as input or output. See also \hyperlink{a00381_cli_hwloc_calc}{hwloc-\/calc}.

\begin{DoxyVerb}# Convert PU with physical number 3 into logical number
$ hwloc-calc -I pu --physical-input --logical-output pu:3
5

# Convert a set of NUMA nodes from logical to physical
# (beware that the output order may not match the input order)
$ hwloc-calc -I numa --logical-input --physical-output numa:2-3 numa:7
0,2,5
\end{DoxyVerb}
\hypertarget{a00394_faq_structural}{}\subsection{hwloc is only a structural model, it ignores performance models, memory bandwidth, etc.?}\label{a00394_faq_structural}
hwloc is indeed designed to provide applications with a structural model of the platform. This is an orthogonal approach to describing the machine with performance models, for instance using memory bandwidth or latencies measured by benchmarks. We believe that both approaches are important for helping application make the most of the hardware.

For instance, on a dual-\/processor host with four cores each, hwloc clearly shows which four cores are together. Latencies between all pairs of cores of the same processor are likely identical, and also likely lower than the latency between cores of different processors. However, the structural model cannot guarantee such implementation details. On the other side, performance models would reveal such details without always clearly identifying which cores are in the same processor.

The focus of hwloc is mainly of the structural modeling side. However, hwloc lets user adds performance information to the topology through distances (see \hyperlink{a00387_topoattrs_distances}{Distances}), memory attributes (see \hyperlink{a00387_topoattrs_memattrs}{Memory Attributes}) or even custom annotations (see \hyperlink{a00394_faq_annotate}{How do I annotate the topology with private notes?}). hwloc may also use such distance information for grouping objects together (see \hyperlink{a00394_faq_onedim}{hwloc only has a one-\/dimensional view of the architecture, it ignores distances?} and \hyperlink{a00394_faq_groups}{What are these Group objects in my topology?}).\hypertarget{a00394_faq_onedim}{}\subsection{hwloc only has a one-\/dimensional view of the architecture, it ignores distances?}\label{a00394_faq_onedim}
hwloc places all objects in a tree. Each level is a one-\/dimensional view of a set of similar objects. All children of the same object (siblings) are assumed to be equally interconnected (same distance between any of them), while the distance between children of different objects (cousins) is supposed to be larger.

Modern machines exhibit complex hardware interconnects, so this tree may miss some information about the actual physical distances between objects. The hwloc topology may therefore be annotated with distance information that may be used to build a more realistic representation (multi-\/dimensional) of each level. For instance, there can be a distance matrix that representing the latencies between any pair of N\+U\+MA nodes if the B\+I\+OS and/or operating system reports them.

For more information about the hwloc distances, see \hyperlink{a00387_topoattrs_distances}{Distances}.\hypertarget{a00394_faq_groups}{}\subsection{What are these Group objects in my topology?}\label{a00394_faq_groups}
hwloc comes with a set of predefined object types (Core, Package, N\+U\+MA node, Caches) that match the vast majority of hardware platforms. The \hyperlink{a00184_ggacd37bb612667dc437d66bfb175a8dc55a5269ef95be72f88465559d35c9b7ad56}{H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+G\+R\+O\+UP} type was designed for cases where this set is not sufficient. Groups may be used anywhere to add more structure information to the topology, for instance to show that 2 out of 4 N\+U\+MA nodes are actually closer than the others. When applicable, the {\ttfamily subtype} field describes why a Group was actually added (see also \hyperlink{a00386_attributes_normal}{Normal attributes}).

hwloc currently uses Groups for the following reasons\+: 
\begin{DoxyItemize}
\item N\+U\+MA parents when memory locality does not match any existing object. 
\item I/O parents when I/O locality does not match any existing object. 
\item Distance-\/based groups made of close objects. 
\item A\+MD Bulldozer dual-\/core compute units ({\ttfamily subtype} is {\ttfamily Compute\+Unit}, in the x86 backend), but these objects are usually merged with the L2 caches. 
\item Intel Extended Topology Enumeration levels (in the x86 backend). 
\item Windows processor groups (unless they contain a single N\+U\+MA node, or a single Package, etc.). 
\item I\+BM S/390 \char`\"{}\+Books\char`\"{} on Linux ({\ttfamily subtype} is {\ttfamily Book}). 
\item A\+IX unknown hierarchy levels. 
\end{DoxyItemize}

hwloc Groups are only kept if no other object has the same locality information. It means that a Group containing a single child is merged into that child. And a Group is merged into its parent if it is its only child. For instance a Windows processor group containing a single N\+U\+MA node would be merged with that N\+U\+MA node since it already contains the relevant hierarchy information.

When inserting a custom Group with hwloc\+\_\+hwloc\+\_\+topology\+\_\+insert\+\_\+group\+\_\+object(), this merging may be disabled by setting its {\ttfamily dont\+\_\+merge} attribute.\hypertarget{a00394_faq_asymmetric}{}\subsection{What happens if my topology is asymmetric?}\label{a00394_faq_asymmetric}
hwloc supports asymmetric topologies even if most platforms are usually symmetric. For example, there could be different types of processors in a single machine, each with different numbers of cores, symmetric multithreading, or levels of caches.

In practice, asymmetric topologies mostly appear when intermediate groups are added for I/O affinity\+: on a 4-\/package machine, an I/O bus may be connected to 2 packages. These packages are below an additional Group object, while the other packages are not (see also \hyperlink{a00394_faq_groups}{What are these Group objects in my topology?}).

To understand how hwloc manages such cases, one should first remember the meaning of levels and cousin objects. All objects of the same type are gathered as horizontal levels with a given depth. They are also connected through the cousin pointers of the \hyperlink{a00238}{hwloc\+\_\+obj} structure. Object attribute (cache depth and type, group depth) are also taken in account when gathering objects as horizontal levels. To be clear\+: there will be one level for L1i caches, another level for L1d caches, another one for L2, etc.

If the topology is asymmetric (e.\+g., if a group is missing above some processors), a given horizontal level will still exist if there exist any objects of that type. However, some branches of the overall tree may not have an object located in that horizontal level. Note that this specific hole within one horizontal level does not imply anything for other levels. All objects of the same type are gathered in horizontal levels even if their parents or children have different depths and types.

See the diagram in \hyperlink{a00380}{Terms and Definitions} for a graphical representation of such topologies.

Moreover, it is important to understand that a same parent object may have children of different types (and therefore, different depths). {\bfseries These children are therefore siblings (because they have the same parent), but they are {\itshape not} cousins (because they do not belong to the same horizontal level).}\hypertarget{a00394_faq_nosmt}{}\subsection{What happens to my topology if I disable symmetric multithreading, hyper-\/threading, etc. in the system?}\label{a00394_faq_nosmt}
hwloc creates one PU (processing unit) object per hardware thread. If your machine supports symmetric multithreading, for instance Hyper-\/\+Threading, each Core object may contain multiple PU objects\+: \begin{DoxyVerb}$ lstopo -
...
  Core L#0
    PU L#0 (P#0)
    PU L#1 (P#2)
  Core L#1
    PU L#2 (P#1)
    PU L#3 (P#3)
\end{DoxyVerb}


x86 machines usually offer the ability to disable hyper-\/threading in the B\+I\+OS. Or it can be disabled on the Linux kernel command-\/line at boot time, or later by writing in sysfs virtual files.

If you do so, the hwloc topology structure does not significantly change, but some PU objects will not appear anymore. No level will disappear, you will see the same number of Core objects, but each of them will contain a single PU now. The PU level does not disappear either (remember that hwloc topologies always contain a PU level at the bottom of the topology) even if there is a single PU object per Core parent. \begin{DoxyVerb}$ lstopo -
...
  Core L#0
    PU L#0 (P#0)
  Core L#1
    PU L#1 (P#1)
\end{DoxyVerb}
\hypertarget{a00394_faq_smt}{}\subsection{How may I ignore symmetric multithreading, hyper-\/threading, etc. in hwloc?}\label{a00394_faq_smt}
First, see \hyperlink{a00394_faq_nosmt}{What happens to my topology if I disable symmetric multithreading, hyper-\/threading, etc. in the system?} for more information about multithreading.

If you need to ignore symmetric multithreading in software, you should likely manipulate hwloc Core objects directly\+: \begin{DoxyVerb}/* get the number of cores */
unsigned nbcores = hwloc_get_nbobjs_by_type(topology, HWLOC_OBJ_CORE);
...
/* get the third core below the first package */
hwloc_obj_t package, core;
package = hwloc_get_obj_by_type(topology, HWLOC_OBJ_PACKAGE, 0);
core = hwloc_get_obj_inside_cpuset_by_type(topology, package->cpuset,
                                           HWLOC_OBJ_CORE, 2);
\end{DoxyVerb}


Whenever you want to bind a process or thread to a core, make sure you singlify its cpuset first, so that the task is actually bound to a single thread within this core (to avoid useless migrations). \begin{DoxyVerb}/* bind on the second core */
hwloc_obj_t core = hwloc_get_obj_by_type(topology, HWLOC_OBJ_CORE, 1);
hwloc_cpuset_t set = hwloc_bitmap_dup(core->cpuset);
hwloc_bitmap_singlify(set);
hwloc_set_cpubind(topology, set, 0);
hwloc_bitmap_free(set);
\end{DoxyVerb}


With hwloc-\/calc or hwloc-\/bind command-\/line tools, you may specify that you only want a single-\/thread within each core by asking for their first PU object\+: \begin{DoxyVerb}$ hwloc-calc core:4-7
0x0000ff00
$ hwloc-calc core:4-7.pu:0
0x00005500
\end{DoxyVerb}


When binding a process on the command-\/line, you may either specify the exact thread that you want to use, or ask hwloc-\/bind to singlify the cpuset before binding \begin{DoxyVerb}$ hwloc-bind core:3.pu:0 -- echo "hello from first thread on core #3"
hello from first thread on core #3
...
$ hwloc-bind core:3 --single -- echo "hello from a single thread on core #3"
hello from a single thread on core #3
\end{DoxyVerb}


 \hypertarget{a00394_faq2}{}\section{Advanced}\label{a00394_faq2}
\hypertarget{a00394_faq_xml}{}\subsection{I do not want hwloc to rediscover my enormous machine topology every time I rerun a process}\label{a00394_faq_xml}
Although the topology discovery is not expensive on common machines, its overhead may become significant when multiple processes repeat the discovery on large machines (for instance when starting one process per core in a parallel application). The machine topology usually does not vary much, except if some cores are stopped/restarted or if the administrator restrictions are modified. Thus rediscovering the whole topology again and again may look useless.

For this purpose, hwloc offers X\+ML import/export and shared memory features.

X\+ML lets you save the discovered topology to a file (for instance with the lstopo program) and reload it later by setting the H\+W\+L\+O\+C\+\_\+\+X\+M\+L\+F\+I\+LE environment variable. The H\+W\+L\+O\+C\+\_\+\+T\+H\+I\+S\+S\+Y\+S\+T\+EM environment variable should also be set to 1 to assert that loaded file is really the underlying system.

Loading a X\+ML topology is usually much faster than querying multiple files or calling multiple functions of the operating system. It is also possible to manipulate such X\+ML files with the C programming interface, and the import/export may also be directed to memory buffer (that may for instance be transmitted between applications through a package). See also \hyperlink{a00388}{Importing and exporting topologies from/to X\+ML files}.

\begin{DoxyNote}{Note}
The environment variable H\+W\+L\+O\+C\+\_\+\+T\+H\+I\+S\+S\+Y\+S\+T\+E\+M\+\_\+\+A\+L\+L\+O\+W\+E\+D\+\_\+\+R\+E\+S\+O\+U\+R\+C\+ES may be used to load a X\+ML topology that contains the entire machine and restrict it to the part that is actually available to the current process (e.\+g. when Linux Cgroup/\+Cpuset are used to restrict the set of resources). See \hyperlink{a00382}{Environment Variables}.
\end{DoxyNote}
Shared-\/memory topologies consist in one process exposing its topology in a shared-\/memory buffer so that other processes (running on the same machine) may use it directly. This has the advantage of reducing the memory footprint since a single topology is stored in physical memory for multiple processes. However, it requires all processes to map this shared-\/memory buffer at the same virtual address, which may be difficult in some cases. This A\+PI is described in \hyperlink{a00226}{Sharing topologies between processes}.\hypertarget{a00394_faq_multitopo}{}\subsection{How many topologies may I use in my program?}\label{a00394_faq_multitopo}
hwloc lets you manipulate multiple topologies at the same time. However, these topologies consume memory and system resources (for instance file descriptors) until they are destroyed. It is therefore discouraged to open the same topology multiple times.

Sharing a single topology between threads is easy (see \hyperlink{a00391}{Thread Safety}) since the vast majority of accesses are read-\/only.

If multiple topologies of different (but similar) nodes are needed in your program, have a look at \hyperlink{a00394_faq_diff}{How to avoid memory waste when manipulating multiple similar topologies?}.\hypertarget{a00394_faq_diff}{}\subsection{How to avoid memory waste when manipulating multiple similar topologies?}\label{a00394_faq_diff}
hwloc does not share information between topologies. If multiple similar topologies are loaded in memory, for instance the topologies of different identical nodes of a cluster, lots of information will be duplicated.

\hyperlink{a00170_source}{hwloc/diff.\+h} (see also \hyperlink{a00225}{Topology differences}) offers the ability to compute topology differences, apply or unapply them, or export/import to/from X\+ML. However, this feature is limited to basic differences such as attribute changes. It does not support complex modifications such as adding or removing some objects.\hypertarget{a00394_faq_annotate}{}\subsection{How do I annotate the topology with private notes?}\label{a00394_faq_annotate}
Each hwloc object contains a {\ttfamily userdata} field that may be used by applications to store private pointers. This field is only valid during the lifetime of these container object and topology. It becomes invalid as soon the topology is destroyed, or as soon as the object disappears, for instance when restricting the topology. The userdata field is not exported/imported to/from X\+ML by default since hwloc does not know what it contains. This behavior may be changed by specifying application-\/specific callbacks with {\ttfamily \hyperlink{a00206_ga9d6ff0f7a8dd45be9aa8575ef31978cc}{hwloc\+\_\+topology\+\_\+set\+\_\+userdata\+\_\+export\+\_\+callback()}} and {\ttfamily \hyperlink{a00206_ga5ac6917ea7289955fb1ffda4353af9b0}{hwloc\+\_\+topology\+\_\+set\+\_\+userdata\+\_\+import\+\_\+callback()}}.

Each object may also contain some {\itshape info} attributes (key name and value) that are setup by hwloc during discovery and that may be extended by the user with {\ttfamily \hyperlink{a00189_gace7654bb8a9002caae1a4b8a59e7452e}{hwloc\+\_\+obj\+\_\+add\+\_\+info()}} (see also \hyperlink{a00386}{Object attributes}). Contrary to the {\ttfamily userdata} field which is unique, multiple info attributes may exist for each object, even with the same name. These attributes are always exported to X\+ML. However, only character strings may be used as key names and values.

It is also possible to insert Misc objects with a custom name anywhere as a leaf of the topology (see \hyperlink{a00385}{Miscellaneous objects}). And Misc objects may have their own userdata and info attributes just like any other object.

The hwloc-\/annotate command-\/line tool may be used for adding Misc objects and info attributes.

There is also a topology-\/specific userdata pointer that can be used to recognize different topologies by storing a custom pointer. It may be manipulated with {\ttfamily \hyperlink{a00193_ga2cc7b7b155cba58dda203e54f1637b9c}{hwloc\+\_\+topology\+\_\+set\+\_\+userdata()}} and {\ttfamily \hyperlink{a00193_ga91f992f8d6c4905b2d3c4f43e509c2a3}{hwloc\+\_\+topology\+\_\+get\+\_\+userdata()}}.

 \hypertarget{a00394_faq3}{}\section{Caveats}\label{a00394_faq3}
\hypertarget{a00394_faq_slow_lstopo}{}\subsection{Why is hwloc slow?}\label{a00394_faq_slow_lstopo}
Building a hwloc topology on a large machine may be slow because the discovery of hundreds of hardware cores or threads takes time (especially when reading thousands of sysfs files on Linux). Ignoring some objects (for instance caches) that aren\textquotesingle{}t useful to the current application may improve this overhead (see \hyperlink{a00394_faq_why}{I only need binding, why should I use hwloc ?}). One should also consider using X\+ML (see \hyperlink{a00394_faq_xml}{I do not want hwloc to rediscover my enormous machine topology every time I rerun a process}) to work around such issues.

Additionally, lstopo enables most hwloc objects and discovery flags by default so that the output topology is as precise as possible (while hwloc disables many of them by default). This includes I/O device discovery through P\+CI libraries as well as external libraries such as N\+V\+ML. To speed up lstopo, you may disable such features with command-\/line options such as {\ttfamily -\/-\/no-\/io}.

When N\+V\+I\+D\+IA G\+PU probing is enabled with C\+U\+DA or N\+V\+ML, one should make sure that the {\itshape Persistent} mode is enabled (with {\ttfamily nvidia-\/smi -\/pm 1}) to avoid significant G\+PU initialization overhead.

When A\+MD G\+PU discovery is enabled with Open\+CL and hwloc is used remotely over ssh, some spurious round-\/trips on the network may significantly increase the discovery time. Forcing the {\ttfamily D\+I\+S\+P\+L\+AY} environment variable to the remote X server display (usually {\ttfamily \+:0}) instead of only setting the {\ttfamily C\+O\+M\+P\+U\+TE} variable may avoid this.

Also remember that these components may be disabled at build-\/time with configure flags such as {\ttfamily -\/-\/disable-\/opencl}, {\ttfamily -\/-\/disable-\/cuda} or {\ttfamily -\/-\/disable-\/nvml}, and at runtime with the environment variable {\ttfamily H\+W\+L\+O\+C\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+TS=-\/opencl,-\/cuda,-\/nvml} or with \hyperlink{a00192_ga9ad41adf418cee1c0ee32ba9bd4a3d36}{hwloc\+\_\+topology\+\_\+set\+\_\+components()}.\hypertarget{a00394_faq_privileged}{}\subsection{Does hwloc require privileged access?}\label{a00394_faq_privileged}
hwloc discovers the topology by querying the operating system. Some minor features may require privileged access to the operation system. For instance memory module discovery on Linux is reserved to root, and the entire P\+CI discovery on Solaris and B\+S\+Ds requires access to some special files that are usually restricted to root (/dev/pci$\ast$ or /devices/pci$\ast$).

To workaround this limitation, it is recommended to export the topology as a X\+ML file generated by the administrator (with the lstopo program) and make it available to all users (see \hyperlink{a00388}{Importing and exporting topologies from/to X\+ML files}). It will offer all discovery information to any application without requiring any privileged access anymore. Only the necessary hardware characteristics will be exported, no sensitive information will be disclosed through this X\+ML export.

This X\+M\+L-\/based model also has the advantage of speeding up the discovery because reading a X\+ML topology is usually much faster than querying the operating system again.

The utility {\ttfamily hwloc-\/dump-\/hwdata} is also involved in gathering privileged information at boot time and making it available to non-\/privileged users (note that this may require a specific S\+E\+Linux M\+LS policy module). However, it only applies to Intel Xeon Phi processors for now (see \hyperlink{a00394_faq_knl_dump}{Why do I need hwloc-\/dump-\/hwdata for memory on Intel Xeon Phi processor?}). See also {\ttfamily H\+W\+L\+O\+C\+\_\+\+D\+U\+M\+P\+E\+D\+\_\+\+H\+W\+D\+A\+T\+A\+\_\+\+D\+IR} in \hyperlink{a00382}{Environment Variables} for details about the location of dumped files.\hypertarget{a00394_faq_os_error}{}\subsection{What should I do when hwloc reports \char`\"{}operating system\char`\"{} warnings?}\label{a00394_faq_os_error}
When the operating system reports invalid locality information (because of either software or hardware bugs), hwloc may fail to insert some objects in the topology because they cannot fit in the already built tree of resources. If so, hwloc will report a warning like the following. The object causing this error is ignored, the discovery continues but the resulting topology will miss some objects and may be asymmetric (see also \hyperlink{a00394_faq_asymmetric}{What happens if my topology is asymmetric?}).

\begin{DoxyVerb}****************************************************************************
* hwloc received invalid information from the operating system.
*
* L3 (cpuset 0x000003f0) intersects with NUMANode (P#0 cpuset 0x0000003f) without inclusion!
* Error occurred in topology.c line 940
*
* Please report this error message to the hwloc user's mailing list,
* along with the files generated by the hwloc-gather-topology script.
*
* hwloc will now ignore this invalid topology information and continue.
****************************************************************************
\end{DoxyVerb}


These errors are common on large A\+MD platforms because of B\+I\+OS and/or Linux kernel bugs causing invalid L3 cache information. In the above example, the hardware reports a L3 cache that is shared by 2 cores in the first N\+U\+MA node and 4 cores in the second N\+U\+MA node. That\textquotesingle{}s wrong, it should actually be shared by all 6 cores in a single N\+U\+MA node. The resulting topology will miss some L3 caches.

If your application does not care about cache sharing, or if you do not plan to request cache-\/aware binding in your process launcher, you may likely ignore this error (and hide it by setting H\+W\+L\+O\+C\+\_\+\+H\+I\+D\+E\+\_\+\+E\+R\+R\+O\+RS=1 in your environment).

Some platforms report similar warnings about conflicting Packages and N\+U\+M\+A\+Nodes.

On x86 hosts, passing {\ttfamily H\+W\+L\+O\+C\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+TS=x86} in the environment may workaround some of these issues by switching to a different way to discover the topology.

Upgrading the B\+I\+OS and/or the operating system may help. Otherwise, as explained in the message, reporting this issue to the hwloc developers (by sending the tarball that is generated by the hwloc-\/gather-\/topology script on this platform) is a good way to make sure that this is a software (operating system) or hardware bug (B\+I\+OS, etc).

See also \hyperlink{index_bugs}{Questions and Bugs}. Opening an issue on Git\+Hub automatically displays hints on what information you should provide when reporting such bugs.\hypertarget{a00394_faq_valgrind}{}\subsection{Why does Valgrind complain about hwloc memory leaks?}\label{a00394_faq_valgrind}
If you are debugging your application with Valgrind, you want to avoid memory leak reports that are caused by hwloc and not by your program.

hwloc itself is often checked with Valgrind to make sure it does not leak memory. However, some global variables in hwloc dependencies are never freed. For instance libz allocates its global state once at startup and never frees it so that it may be reused later. Some libxml2 global state is also never freed because hwloc does not know whether it can safely ask libxml2 to free it (the application may also be using libxml2 outside of hwloc).

These unfreed variables cause leak reports in Valgrind. hwloc installs a Valgrind {\itshape suppressions} file to hide them. You should pass the following command-\/line option to Valgrind to use it\+: \begin{DoxyVerb}  --suppressions=/path/to/hwloc-valgrind.supp
\end{DoxyVerb}


 \hypertarget{a00394_faq4}{}\section{Platform-\/specific}\label{a00394_faq4}
\hypertarget{a00394_faq_knl_numa}{}\subsection{How do I find the local M\+C\+D\+R\+A\+M N\+U\+M\+A node on Intel Xeon Phi processor?}\label{a00394_faq_knl_numa}
Intel Xeon Phi processors introduced a new memory architecture by possibly having two distinct local memories\+: some normal memory (D\+DR) and some high-\/bandwidth on-\/package memory (M\+C\+D\+R\+AM). Processors can be configured in various clustering modes to have up to 4 {\itshape Clusters}. Moreover, each {\itshape Cluster} (quarter, half or whole processor) of the processor may have its own local parts of the D\+DR and of the M\+C\+D\+R\+AM. This memory and clustering configuration may be probed by looking at Memory\+Mode and Cluster\+Mode attributes, see \hyperlink{a00386_attributes_info_platform}{Hardware Platform Information} and doc/examples/get-\/knl-\/modes.\+c in the source directory.

Starting with version 2.\+0, hwloc properly exposes this memory configuration. D\+DR and M\+C\+D\+R\+AM are attached as two memory children of the same parent, D\+DR first, and M\+C\+D\+R\+AM second if any. Depending on the processor configuration, that parent may be a Package, a Cache, or a Group object of type {\ttfamily Cluster}.

Hence cores may have one or two local N\+U\+MA nodes, listed by the core nodeset. An application may allocate local memory from a core by using that nodeset. The operating system will actually allocate from the D\+DR when possible, or fallback to the M\+C\+D\+R\+AM.

To allocate specifically on one of these memories, one should walk up the parent pointers until finding an object with some memory children. Looking at these memory children will give the D\+DR first, then the M\+C\+D\+R\+AM if any. Their nodeset may then be used for allocating or binding memory buffers.

One may also traverse the list of N\+U\+MA nodes until finding some whose cpuset matches the target core or P\+Us. The M\+C\+D\+R\+AM N\+U\+MA nodes may be identified thanks to the {\ttfamily subtype} field which is set to {\ttfamily M\+C\+D\+R\+AM}.

Command-\/line tools such as {\ttfamily hwloc-\/bind} may bind memory on the M\+C\+D\+R\+AM by using the {\itshape hbm} keyword. For instance, to bind on the first M\+C\+D\+R\+AM N\+U\+MA node\+:

\begin{DoxyVerb}$ hwloc-bind --membind --hbm numa:0 -- myprogram
$ hwloc-bind --membind numa:0 -- myprogram
\end{DoxyVerb}
\hypertarget{a00394_faq_knl_dump}{}\subsection{Why do I need hwloc-\/dump-\/hwdata for memory on Intel Xeon Phi processor?}\label{a00394_faq_knl_dump}
Intel Xeon Phi processors may use the on-\/package memory (M\+C\+D\+R\+AM) as either memory or a memory-\/side cache (reported as a L3 cache by hwloc by default, see {\ttfamily H\+W\+L\+O\+C\+\_\+\+K\+N\+L\+\_\+\+M\+S\+C\+A\+C\+H\+E\+\_\+\+L3} in \hyperlink{a00382}{Environment Variables}). There are also several clustering modes that significantly affect the memory organization (see \hyperlink{a00394_faq_knl_numa}{How do I find the local M\+C\+D\+R\+AM N\+U\+MA node on Intel Xeon Phi processor?} for more information about these modes). Details about these are currently only available to privileged users. Without them, hwloc relies on a heuristic for guessing the modes.

The hwloc-\/dump-\/hwdata utility may be used to dump this privileged binary information into human-\/readable and world-\/accessible files that the hwloc library will later load. The utility should usually run as root once during boot, in order to update dumped information (stored under /var/run/hwloc by default) in case the M\+C\+D\+R\+AM or clustering configuration changed between reboots.

When S\+E\+Linux M\+LS policy is enabled, a specific hwloc policy module may be required so that all users get access to the dumped files (in /var/run/hwloc by default). One may use hwloc policy files from the S\+E\+Linux Reference Policy at \href{https://github.com/TresysTechnology/refpolicy-contrib}{\tt https\+://github.\+com/\+Tresys\+Technology/refpolicy-\/contrib} (see also the documentation at \href{https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted}{\tt https\+://github.\+com/\+Tresys\+Technology/refpolicy/wiki/\+Getting\+Started}).

hwloc-\/dump-\/hwdata requires {\ttfamily dmi-\/sysfs} kernel module loaded.

The utility is currently unneeded on platforms without Intel Xeon Phi processors.

See {\ttfamily H\+W\+L\+O\+C\+\_\+\+D\+U\+M\+P\+E\+D\+\_\+\+H\+W\+D\+A\+T\+A\+\_\+\+D\+IR} in \hyperlink{a00382}{Environment Variables} for details about the location of dumped files.\hypertarget{a00394_faq_bgq}{}\subsection{How do I build hwloc for Blue\+Gene/\+Q?}\label{a00394_faq_bgq}
I\+BM Blue\+Gene/Q machines run a standard Linux on the login/frontend nodes and a custom C\+NK ({\itshape Compute Node Kernel}) on the compute nodes.

To discover the topology of a login/frontend node, hwloc should be configured as usual, without any Blue\+Gene/\+Q-\/specific option.

However, one would likely rather discover the topology of the compute nodes where parallel jobs are actually running. If so, hwloc must be cross-\/compiled with the following configuration line\+: \begin{DoxyVerb}./configure --host=powerpc64-bgq-linux --disable-shared --enable-static \
  CPPFLAGS='-I/bgsys/drivers/ppcfloor -I/bgsys/drivers/ppcfloor/spi/include/kernel/cnk/'
\end{DoxyVerb}


C\+P\+P\+F\+L\+A\+GS may have to be updated if your platform headers are installed in a different directory.\hypertarget{a00394_faq_windows}{}\subsection{How do I build hwloc for Windows?}\label{a00394_faq_windows}
hwloc releases are available as pre-\/built Z\+I\+Ps for Windows on both 32bits and 64bits x86 platforms. They are built using M\+S\+Y\+S2 and Min\+GW on a Windows host. Such an environment allows using the Unix-\/like {\ttfamily configure}, {\ttfamily make} and {\ttfamily make install} steps without having to tweak too many variables or options. One may look at {\ttfamily contrib/ci.\+inria.\+fr/job-\/3-\/mingw.sh} in the hwloc repository for an example used for nightly testing.

hwloc releases also contain a basic Microsoft Visual Studio solution under {\ttfamily contrib/windows/}.\hypertarget{a00394_faq_netbsd_bind}{}\subsection{How to get useful topology information on Net\+B\+S\+D?}\label{a00394_faq_netbsd_bind}
The Net\+B\+SD (and Free\+B\+SD) backend uses x86-\/specific topology discovery (through the x86 component). This implementation requires C\+PU binding so as to query topology information from each individual processor. This means that hwloc cannot find any useful topology information unless user-\/level process binding is allowed by the Net\+B\+SD kernel. The {\ttfamily security.\+models.\+extensions.\+user\+\_\+set\+\_\+cpu\+\_\+affinity} sysctl variable must be set to 1 to do so. Otherwise, only the number of processors will be detected.\hypertarget{a00394_faq_aix_bind}{}\subsection{Why does binding fail on A\+I\+X?}\label{a00394_faq_aix_bind}
The A\+IX operating system requires specific user capabilities for attaching processes to resource sets (C\+A\+P\+\_\+\+N\+U\+M\+A\+\_\+\+A\+T\+T\+A\+CH). Otherwise functions such as \hyperlink{a00190_ga80bc07473a8edf840cae17bd7ec21d48}{hwloc\+\_\+set\+\_\+cpubind()} fail (return -\/1 with errno set to E\+P\+E\+RM).

This capability must also be inherited (through the additional C\+A\+P\+\_\+\+P\+R\+O\+P\+A\+G\+A\+TE capability) if you plan to bind a process before forking another process, for instance with {\ttfamily hwloc-\/bind}.

These capabilities may be given by the administrator with\+: \begin{DoxyVerb}chuser "capabilities=CAP_PROPAGATE,CAP_NUMA_ATTACH" <username>
\end{DoxyVerb}


 \hypertarget{a00394_faq5}{}\section{Compatibility between hwloc versions}\label{a00394_faq5}
\hypertarget{a00394_faq_version_api}{}\subsection{How do I handle A\+P\+I changes?}\label{a00394_faq_version_api}
The hwloc interface is extended with every new major release. Any application using the hwloc A\+PI should be prepared to check at compile-\/time whether some features are available in the currently installed hwloc distribution.

For instance, to check whether the hwloc version is at least 2.\+0, you should use\+: \begin{DoxyVerb}#include <hwloc.h>
#if HWLOC_API_VERSION >= 0x00020000
...
#endif
\end{DoxyVerb}


To check for the A\+PI of release X.\+Y.\+Z at build time, you may compare \hyperlink{a00182_ga8f4dfb8eef138af55dd1a0fa802e5476}{H\+W\+L\+O\+C\+\_\+\+A\+P\+I\+\_\+\+V\+E\+R\+S\+I\+ON} with {\ttfamily (X$<$$<$16)+(Y$<$$<$8)+Z}.

For supporting older releases that do not have {\ttfamily H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+N\+U\+M\+A\+N\+O\+DE} and {\ttfamily H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+P\+A\+C\+K\+A\+GE} yet, you may use\+:

\begin{DoxyVerb}#include <hwloc.h>
#if HWLOC_API_VERSION < 0x00010b00
#define HWLOC_OBJ_NUMANODE HWLOC_OBJ_NODE
#define HWLOC_OBJ_PACKAGE HWLOC_OBJ_SOCKET
#endif
\end{DoxyVerb}


Once a program is built against a hwloc library, it may also dynamically link with compatible libraries from other hwloc releases. The version of that runtime library may be queried with \hyperlink{a00182_ga9c0b50c98add1adf57ed1ce85bb5190d}{hwloc\+\_\+get\+\_\+api\+\_\+version()}. See \hyperlink{a00394_faq_version_abi}{How do I handle A\+BI breaks?} for using this function for testing A\+BI compatibility.\hypertarget{a00394_faq_version}{}\subsection{What is the difference between A\+P\+I and library version numbers?}\label{a00394_faq_version}
\hyperlink{a00182_ga8f4dfb8eef138af55dd1a0fa802e5476}{H\+W\+L\+O\+C\+\_\+\+A\+P\+I\+\_\+\+V\+E\+R\+S\+I\+ON} is the version of the A\+PI. It changes when functions are added, modified, etc. However it does not necessarily change from one release to another. For instance, two releases of the same series (e.\+g. 2.\+0.\+3 and 2.\+0.\+4) usually have the same \hyperlink{a00182_ga8f4dfb8eef138af55dd1a0fa802e5476}{H\+W\+L\+O\+C\+\_\+\+A\+P\+I\+\_\+\+V\+E\+R\+S\+I\+ON} ({\ttfamily 0x00020000}). However their H\+W\+L\+O\+C\+\_\+\+V\+E\+R\+S\+I\+ON strings are different ({\ttfamily "2.\+0.\+3"} and {\ttfamily "2.\+0.\+4"} respectively).\hypertarget{a00394_faq_version_abi}{}\subsection{How do I handle A\+B\+I breaks?}\label{a00394_faq_version_abi}
The hwloc interface was deeply modified in release 2.\+0 to fix several issues of the 1.\+x interface (see \hyperlink{a00395}{Upgrading to the hwloc 2.\+0 A\+PI} and the N\+E\+WS file in the source directory for details). The A\+BI was broken, which means {\bfseries applications must be recompiled against the new 2.\+0 interface}.

To check that you are not mixing old/recent headers with a recent/old runtime library, check the major revision number in the A\+PI version\+: \begin{DoxyVerb}#include <hwloc.h>
  unsigned version = hwloc_get_api_version();
  if ((version >> 16) != (HWLOC_API_VERSION >> 16)) {
    fprintf(stderr,
           "%s compiled for hwloc API 0x%x but running on library API 0x%x.\n"
           "You may need to point LD_LIBRARY_PATH to the right hwloc library.\n"
           "Aborting since the new ABI is not backward compatible.\n",
           callname, HWLOC_API_VERSION, version);
    exit(EXIT_FAILURE);
  }
\end{DoxyVerb}
 To specifically detect v2.\+0 issues\+: \begin{DoxyVerb}#include <hwloc.h>
#if HWLOC_API_VERSION >= 0x00020000
  /* headers are recent */
  if (hwloc_get_api_version() < 0x20000)
    ... error out, the hwloc runtime library is older than 2.0 ...
#else
  /* headers are pre-2.0 */
  if (hwloc_get_api_version() >= 0x20000)
    ... error out, the hwloc runtime library is more recent than 2.0 ...
#endif
\end{DoxyVerb}


In theory, library sonames prevent linking with incompatible libraries. However custom hwloc installations or improperly configured build environments may still lead to such issues. Hence running one of the above (cheap) checks before initializing hwloc topology may be useful.\hypertarget{a00394_faq_version_xml}{}\subsection{Are X\+M\+L topology files compatible between hwloc releases?}\label{a00394_faq_version_xml}
X\+ML topology files are forward-\/compatible\+: a X\+ML file may be loaded by a hwloc library that is more recent than the hwloc release that exported that file.

However, hwloc X\+M\+Ls are not always backward-\/compatible\+: Topologies exported by hwloc 2.\+x cannot be imported by 1.\+x by default (see \hyperlink{a00395_upgrade_to_api_2x_xml}{X\+ML changes} for working around such issues). There are also some corner cases where backward compatibility is not guaranteed because of changes between major releases (for instance 1.\+11 X\+M\+Ls could not be imported in 1.\+10).

X\+M\+Ls are exchanged at runtime between some components of the H\+PC software stack (for instance the resource managers and M\+PI processes). Building all these components on the same (cluster-\/wide) hwloc installation is a good way to avoid such incompatibilities.\hypertarget{a00394_faq_version_synthetic}{}\subsection{Are synthetic strings compatible between hwloc releases?}\label{a00394_faq_version_synthetic}
Synthetic strings (see \hyperlink{a00389}{Synthetic topologies}) are forward-\/compatible\+: a synthetic string generated by a release may be imported by future hwloc libraries.

However they are often not backward-\/compatible because new details may have been added to synthetic descriptions in recent releases. Some flags may be given to \hyperlink{a00207_ga24b7864a1c588309c4749f621f03b4c7}{hwloc\+\_\+topology\+\_\+export\+\_\+synthetic()} to avoid such details and stay backward compatible.\hypertarget{a00394_faq_version_shmem}{}\subsection{Is it possible to share a shared-\/memory topology between different hwloc releases?}\label{a00394_faq_version_shmem}
Shared-\/memory topologies (see \hyperlink{a00226}{Sharing topologies between processes}) have strong requirements on compatibility between hwloc libraries. Adopting a shared-\/memory topology fails if it was exported by a non-\/compatible hwloc release. Releases with same major revision are usually compatible (e.\+g. hwloc 2.\+0.\+4 may adopt a topology exported by 2.\+0.\+3) but different major revisions may be incompatible (e.\+g. hwloc 2.\+1.\+0 cannot adopt from 2.\+0.\+x).

Topologies are shared at runtime between some components of the H\+PC software stack (for instance the resource managers and M\+PI processes). Building all these components on the same (system-\/wide) hwloc installation is a good way to avoid such incompatibilities. 