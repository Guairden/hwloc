

See \hyperlink{a00394_faq5}{Compatibility between hwloc versions} for detecting the hwloc version that you are compiling and/or running against.

 \hypertarget{a00395_upgrade_to_api_2x_memory}{}\section{New Organization of N\+U\+M\+A nodes and Memory}\label{a00395_upgrade_to_api_2x_memory}
\hypertarget{a00395_upgrade_to_api_2x_memory_children}{}\subsection{Memory children}\label{a00395_upgrade_to_api_2x_memory_children}
In hwloc v1.\+x, N\+U\+MA nodes were inside the tree, for instance Packages contained 2 N\+U\+MA nodes which contained a L3 and several cache.

Starting with hwloc v2.\+0, N\+U\+MA nodes are not in the main tree anymore. They are attached under objects as {\itshape Memory Children} on the side of normal children. This memory children list starts at {\ttfamily obj-\/$>$memory\+\_\+first\+\_\+child} and its size is {\ttfamily obj-\/$>$memory\+\_\+arity}. Hence there can now exist two local N\+U\+MA nodes, for instance on Intel Xeon Phi processors.

The normal list of children (starting at {\ttfamily obj-\/$>$first\+\_\+child}, ending at {\ttfamily obj-\/$>$last\+\_\+child}, of size {\ttfamily obj-\/$>$arity}, and available as the array {\ttfamily obj-\/$>$children}) now only contains C\+P\+U-\/side objects\+: P\+Us, Cores, Packages, Caches, Groups, Machine and System. \hyperlink{a00197_ga12d8565a3436c565e791ed02a0353621}{hwloc\+\_\+get\+\_\+next\+\_\+child()} may still be used to iterate over all children of all lists.

Hence the C\+P\+U-\/side hierarchy is built using normal children, while memory is attached to that hierarchy depending on its affinity.\hypertarget{a00395_upgrade_to_api_2x_memory_examples}{}\subsection{Examples}\label{a00395_upgrade_to_api_2x_memory_examples}

\begin{DoxyItemize}
\item a U\+MA machine with 2 packages and a single N\+U\+MA node is now modeled as a \char`\"{}\+Machine\char`\"{} object with two \char`\"{}\+Package\char`\"{} children and one \char`\"{}\+N\+U\+M\+A\+Node\char`\"{} memory children (displayed first in lstopo below)\+: \begin{DoxyVerb}Machine (1024MB total)
  NUMANode L#0 (P#0 1024MB)
  Package L#0
    Core L#0 + PU L#0 (P#0)
    Core L#1 + PU L#1 (P#1)
  Package L#1
    Core L#2 + PU L#2 (P#2)
    Core L#3 + PU L#3 (P#3)
\end{DoxyVerb}
 


\item a machine with 2 packages with one N\+U\+MA node and 2 cores in each is now\+: \begin{DoxyVerb}Machine (2048MB total)
  Package L#0
    NUMANode L#0 (P#0 1024MB)
    Core L#0 + PU L#0 (P#0)
    Core L#1 + PU L#1 (P#1)
  Package L#1
    NUMANode L#1 (P#1 1024MB)
    Core L#2 + PU L#2 (P#2)
    Core L#3 + PU L#3 (P#3)
\end{DoxyVerb}
 


\item if there are two N\+U\+MA nodes per package, a Group object may be added to keep cores together with their local N\+U\+MA node\+: \begin{DoxyVerb}Machine (4096MB total)
  Package L#0
    Group0 L#0
      NUMANode L#0 (P#0 1024MB)
      Core L#0 + PU L#0 (P#0)
      Core L#1 + PU L#1 (P#1)
    Group0 L#1
      NUMANode L#1 (P#1 1024MB)
      Core L#2 + PU L#2 (P#2)
      Core L#3 + PU L#3 (P#3)
  Package L#1
    [...]
\end{DoxyVerb}
 


\item if the platform has L3 caches whose localities are identical to N\+U\+MA nodes, Groups aren\textquotesingle{}t needed\+: \begin{DoxyVerb}Machine (4096MB total)
  Package L#0
    L3 L#0 (16MB)
      NUMANode L#0 (P#0 1024MB)
      Core L#0 + PU L#0 (P#0)
      Core L#1 + PU L#1 (P#1)
    L3 L#1 (16MB)
      NUMANode L#1 (P#1 1024MB)
      Core L#2 + PU L#2 (P#2)
      Core L#3 + PU L#3 (P#3)
  Package L#1
    [...]
\end{DoxyVerb}
  
\end{DoxyItemize}\hypertarget{a00395_upgrade_to_api_2x_numa_level}{}\subsection{N\+U\+M\+A level and depth}\label{a00395_upgrade_to_api_2x_numa_level}
N\+U\+MA nodes are not in \char`\"{}main\char`\"{} tree of normal objects anymore. Hence, they don\textquotesingle{}t have a meaningful depth anymore (like I/O and Misc objects). They have a virtual (negative) depth (\hyperlink{a00187_ggaf4e663cf42bbe20756b849c6293ef575a245c34ec9884c2cf5de5049b2153ed9c}{H\+W\+L\+O\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+D\+E\+P\+T\+H\+\_\+\+N\+U\+M\+A\+N\+O\+DE}) so that functions manipulating depths and level still work, and so that we can still iterate over the level of N\+U\+MA nodes just like for any other level.

For instance we can still use lines such as \begin{DoxyVerb}int depth = hwloc_get_type_depth(topology, HWLOC_OBJ_NUMANODE);
hwloc_obj_t obj = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, 4);
hwloc_obj_t node = hwloc_get_next_obj_by_depth(topology, HWLOC_TYPE_DEPTH_NUMANODE, prev);
\end{DoxyVerb}


The N\+U\+MA depth should not be compared with others. An unmodified code that still compares N\+U\+MA and Package depths (to find out whether Packages contain N\+U\+MA or the contrary) would now always assume Packages contain N\+U\+MA (because the N\+U\+MA depth is negative).

However, the depth of the Normal parents of N\+U\+MA nodes may be used instead. In the last example above, N\+U\+MA nodes are attached to L3 caches, hence one may compare the depth of Packages and L3 to find out that N\+U\+MA nodes are contained in Packages. This depth of parents may be retrieved with \hyperlink{a00187_gae85786340b88e24835f8c403a1e2e54b}{hwloc\+\_\+get\+\_\+memory\+\_\+parents\+\_\+depth()}. However, this function may return \hyperlink{a00187_ggaf4e663cf42bbe20756b849c6293ef575ae99465995cacde6c210d5fc2e409798c}{H\+W\+L\+O\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+D\+E\+P\+T\+H\+\_\+\+M\+U\+L\+T\+I\+P\+LE} on future platforms if N\+U\+MA nodes are attached to different levels.\hypertarget{a00395_upgrade_to_api_2x_memory_find}{}\subsection{Finding Local N\+U\+M\+A nodes and looking at Children and Parents}\label{a00395_upgrade_to_api_2x_memory_find}
Applications that walked up/down to find N\+U\+M\+A\+Node parent/children must now be updated. Instead of looking directly for a N\+U\+MA node, one should now look for an object that has some memory children. N\+U\+MA node(s) will be attached there. For instance, when looking for a N\+U\+MA node above a given core {\ttfamily core}\+: \begin{DoxyVerb}hwloc_obj_t parent = core->parent;
while (parent && !parent->memory_arity)
  parent = parent->parent; /* no memory child, walk up */
if (parent)
  /* use parent->memory_first_child (and its siblings if there are multiple local NUMA nodes) */
\end{DoxyVerb}


The list of local N\+U\+MA nodes (usually a single one) is also described by the {\ttfamily nodeset} attribute of each object (which contains the physical indexes of these nodes). Iterating over the N\+U\+MA level is also an easy way to find local N\+U\+MA nodes\+: \begin{DoxyVerb}hwloc_obj_t tmp = NULL;
while ((tmp = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_NUMANODE, tmp)) != NULL) {
  if (hwloc_bitmap_isset(obj->nodeset, tmp->os_index))
    /* tmp is a NUMA node local to obj, use it */
}
\end{DoxyVerb}


Similarly finding objects that are close to a given N\+U\+MA nodes should be updated too. Instead of looking at the N\+U\+MA node parents/children, one should now find a Normal parent above that N\+U\+MA node, and then look at its parents/children as usual\+: \begin{DoxyVerb}hwloc_obj_t tmp = obj->parent;
while (hwloc_obj_type_is_memory(tmp))
  tmp = tmp->parent;
/* now use tmp instead of obj */
\end{DoxyVerb}


To avoid such hwloc v2.\+x-\/specific and N\+U\+M\+A-\/specific cases in the code, a {\bfseries generic lookup for any kind of object, including N\+U\+MA nodes}, might also be implemented by iterating over a level. For instance finding an object of type {\ttfamily type} which either contains or is included in object {\ttfamily obj} can be performed by traversing the level of that type and comparing C\+PU sets\+: \begin{DoxyVerb}hwloc_obj_t tmp = NULL;
while ((tmp = hwloc_get_next_obj_by_type(topology, type, tmp)) != NULL) {
  if (hwloc_bitmap_intersects(tmp->cpuset, obj->cpuset))
    /* tmp matches, use it */
}
\end{DoxyVerb}
 {\bfseries  This generic lookup works whenever {\ttfamily type} or {\ttfamily obj} are Normal or Memory objects since both have C\+PU sets. Moreover, it is compatible with the hwloc v1.\+x A\+PI. }

 \hypertarget{a00395_upgrade_to_api_2x_children}{}\section{4 Kinds of Objects and Children}\label{a00395_upgrade_to_api_2x_children}
\hypertarget{a00395_upgrade_to_api_2x_io_misc_children}{}\subsection{I/\+O and Misc children}\label{a00395_upgrade_to_api_2x_io_misc_children}
I/O children are not in the main object children list anymore either. They are in the list starting at {\ttfamily obj-\/$>$io\+\_\+first\+\_\+child} and its size is {\ttfamily obj-\/$>$io\+\_\+arity}.

Misc children are not in the main object children list anymore. They are in the list starting at {\ttfamily obj-\/$>$misc\+\_\+first\+\_\+child} and its size is {\ttfamily obj-\/$>$misc\+\_\+arity}.

See \hyperlink{a00238}{hwloc\+\_\+obj} for details about children lists.

\hyperlink{a00197_ga12d8565a3436c565e791ed02a0353621}{hwloc\+\_\+get\+\_\+next\+\_\+child()} may still be used to iterate over all children of all lists.\hypertarget{a00395_upgrade_to_api_2x_kinds_subsec}{}\subsection{Kinds of objects}\label{a00395_upgrade_to_api_2x_kinds_subsec}
Given the above, objects may now be of 4 kinds\+: 
\begin{DoxyItemize}
\item Normal (everything not listed below, including Machine, Package, Core, PU, C\+PU Caches, etc); 
\item Memory (currently N\+U\+MA nodes or Memory-\/side Caches), attached to parents as Memory children; 
\item I/O (Bridges, P\+CI and OS devices), attached to parents as I/O children; 
\item Misc objects, attached to parents as Misc children. 
\end{DoxyItemize}See \hyperlink{a00238}{hwloc\+\_\+obj} for details about children lists.

For a given object type, the kind may be found with \hyperlink{a00198_ga52ef38431eba383b048b98c669b59a16}{hwloc\+\_\+obj\+\_\+type\+\_\+is\+\_\+normal()}, \hyperlink{a00198_ga1d074390c8a3dc3088d84f73fb73f966}{hwloc\+\_\+obj\+\_\+type\+\_\+is\+\_\+memory()}, \hyperlink{a00198_ga52ef38431eba383b048b98c669b59a16}{hwloc\+\_\+obj\+\_\+type\+\_\+is\+\_\+normal()}, or comparing with \hyperlink{a00184_ggacd37bb612667dc437d66bfb175a8dc55a19f8a6953fa91efc76bcbcdf2d22de4d}{H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+M\+I\+SC}.

Normal and Memory objects have (non-\/\+N\+U\+LL) C\+PU sets and nodesets, while I/O and Misc objects don\textquotesingle{}t have any sets (they are N\+U\+LL).

 \hypertarget{a00395_upgrade_to_api_2x_cache}{}\section{H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+C\+A\+C\+H\+E replaced}\label{a00395_upgrade_to_api_2x_cache}
Instead of a single H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+C\+A\+C\+HE, there are now 8 types \hyperlink{a00184_ggacd37bb612667dc437d66bfb175a8dc55a56389b8eb2e2f74f288bb657c4e72140}{H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+L1\+C\+A\+C\+HE}, ..., \hyperlink{a00184_ggacd37bb612667dc437d66bfb175a8dc55a67194c9de5e3e581c64c11d2eb1c109d}{H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+L5\+C\+A\+C\+HE}, \hyperlink{a00184_ggacd37bb612667dc437d66bfb175a8dc55afa834a85d9e53836cf0db6d0bd8329b4}{H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+L1\+I\+C\+A\+C\+HE}, ..., \hyperlink{a00184_ggacd37bb612667dc437d66bfb175a8dc55ac22850c717f07bf7ffb316fadd08d218}{H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+L3\+I\+C\+A\+C\+HE}.

Cache object attributes are unchanged.

\hyperlink{a00199_gad108a09ce400222fe45545257d575489}{hwloc\+\_\+get\+\_\+cache\+\_\+type\+\_\+depth()} is not needed to disambiguate cache types anymore since new types can be passed to \hyperlink{a00187_ga8bec782e21be313750da70cf7428b374}{hwloc\+\_\+get\+\_\+type\+\_\+depth()} without ever getting \hyperlink{a00187_ggaf4e663cf42bbe20756b849c6293ef575ae99465995cacde6c210d5fc2e409798c}{H\+W\+L\+O\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+D\+E\+P\+T\+H\+\_\+\+M\+U\+L\+T\+I\+P\+LE} anymore.

\hyperlink{a00198_ga2ed589bea28711e80b92066510a5607d}{hwloc\+\_\+obj\+\_\+type\+\_\+is\+\_\+cache()}, \hyperlink{a00198_ga395e48cd221d107e5891689624e1aec4}{hwloc\+\_\+obj\+\_\+type\+\_\+is\+\_\+dcache()} and \hyperlink{a00198_ga8abcee67b9b074332c1866405a3648a9}{hwloc\+\_\+obj\+\_\+type\+\_\+is\+\_\+icache()} may be used to check whether a given type is a cache, data/unified cache or instruction cache.

 \hypertarget{a00395_upgrade_to_api_2x_allowed}{}\section{allowed\+\_\+cpuset and allowed\+\_\+nodeset only in the main topology}\label{a00395_upgrade_to_api_2x_allowed}
Objects do not have {\ttfamily allowed\+\_\+cpuset} and {\ttfamily allowed\+\_\+nodeset} anymore. They are only available for the entire topology using \hyperlink{a00202_ga517d5d68ec9f24583d8933aab713be8e}{hwloc\+\_\+topology\+\_\+get\+\_\+allowed\+\_\+cpuset()} and \hyperlink{a00202_ga21a4d7237a11e76b912ed4524ab78cbd}{hwloc\+\_\+topology\+\_\+get\+\_\+allowed\+\_\+nodeset()}.

As usual, those are only needed when the I\+N\+C\+L\+U\+D\+E\+\_\+\+D\+I\+S\+A\+L\+L\+O\+W\+ED topology flag is given, which means disallowed objects are kept in the topology. If so, one may find out whether some P\+Us inside an object is allowed by checking \begin{DoxyVerb}hwloc_bitmap_intersects(obj->cpuset, hwloc_topology_get_allowed_cpuset(topology))
\end{DoxyVerb}
 Replace cpusets with nodesets for N\+U\+MA nodes. To find out which ones, replace intersects() with and() to get the actual intersection.

 \hypertarget{a00395_upgrade_to_api_2x_depth}{}\section{Object depths are now signed int}\label{a00395_upgrade_to_api_2x_depth}
{\ttfamily obj-\/$>$depth} as well as depths given to functions such as \hyperlink{a00187_ga391f6b2613f0065673eaa4069b93d4e0}{hwloc\+\_\+get\+\_\+obj\+\_\+by\+\_\+depth()} or returned by \hyperlink{a00187_gae54d1782ca9b54bea915f5c18a9158fa}{hwloc\+\_\+topology\+\_\+get\+\_\+depth()} are now {\bfseries signed int}.

Other depth such as cache-\/specific depth attribute are still unsigned.

 \hypertarget{a00395_upgrade_to_api_2x_memory_attrs}{}\section{Memory attributes become N\+U\+M\+A\+Node-\/specific}\label{a00395_upgrade_to_api_2x_memory_attrs}
Memory attributes such as {\ttfamily obj-\/$>$memory.\+local\+\_\+memory} are now only available in N\+U\+M\+A\+Node-\/specific attributes in {\ttfamily obj-\/$>$attr-\/$>$numanode.\+local\+\_\+memory}.

{\ttfamily obj-\/$>$memory.\+total\+\_\+memory} is available in all objects as {\ttfamily obj-\/$>$total\+\_\+memory}.

See \hyperlink{a00246}{hwloc\+\_\+obj\+\_\+attr\+\_\+u\+::hwloc\+\_\+numanode\+\_\+attr\+\_\+s} and \hyperlink{a00238}{hwloc\+\_\+obj} for details.

 \hypertarget{a00395_upgrade_to_api_2x_config}{}\section{Topology configuration changes}\label{a00395_upgrade_to_api_2x_config}
The old ignoring A\+PI as well as several configuration flags are replaced with the new filtering A\+PI, see \hyperlink{a00193_gad894e70f15f8d4aada7be8d1aba38b7e}{hwloc\+\_\+topology\+\_\+set\+\_\+type\+\_\+filter()} and its variants, and \hyperlink{a00193_ga9a5a1f0140cd1952544477833733195b}{hwloc\+\_\+type\+\_\+filter\+\_\+e} for details.


\begin{DoxyItemize}
\item hwloc\+\_\+topology\+\_\+ignore\+\_\+type(), hwloc\+\_\+topology\+\_\+ignore\+\_\+type\+\_\+keep\+\_\+structure() and hwloc\+\_\+topology\+\_\+ignore\+\_\+all\+\_\+keep\+\_\+structure() are respectively superseded by \begin{DoxyVerb}hwloc_topology_set_type_filter(topology, type, HWLOC_TYPE_FILTER_KEEP_NONE);
hwloc_topology_set_type_filter(topology, type, HWLOC_TYPE_FILTER_KEEP_STRUCTURE);
hwloc_topology_set_all_types_filter(topology, HWLOC_TYPE_FILTER_KEEP_STRUCTURE);
\end{DoxyVerb}


Also, the meaning of K\+E\+E\+P\+\_\+\+S\+T\+R\+U\+C\+T\+U\+RE has changed (only entire levels may be ignored, instead of single objects), the old behavior is not available anymore. 


\item H\+W\+L\+O\+C\+\_\+\+T\+O\+P\+O\+L\+O\+G\+Y\+\_\+\+F\+L\+A\+G\+\_\+\+I\+C\+A\+C\+H\+ES is superseded by \begin{DoxyVerb}hwloc_topology_set_icache_types_filter(topology, HWLOC_TYPE_FILTER_KEEP_ALL);
\end{DoxyVerb}
 


\item H\+W\+L\+O\+C\+\_\+\+T\+O\+P\+O\+L\+O\+G\+Y\+\_\+\+F\+L\+A\+G\+\_\+\+W\+H\+O\+L\+E\+\_\+\+IO, H\+W\+L\+O\+C\+\_\+\+T\+O\+P\+O\+L\+O\+G\+Y\+\_\+\+F\+L\+A\+G\+\_\+\+I\+O\+\_\+\+D\+E\+V\+I\+C\+ES and H\+W\+L\+O\+C\+\_\+\+T\+O\+P\+O\+L\+O\+G\+Y\+\_\+\+F\+L\+A\+G\+\_\+\+I\+O\+\_\+\+B\+R\+I\+D\+G\+ES replaced.

To keep all I/O devices (P\+CI, Bridges, and OS devices), use\+: \begin{DoxyVerb}hwloc_topology_set_io_types_filter(topology, HWLOC_TYPE_FILTER_KEEP_ALL);
\end{DoxyVerb}


To only keep important devices (Bridges with children, common P\+CI devices and OS devices)\+: \begin{DoxyVerb}hwloc_topology_set_io_types_filter(topology, HWLOC_TYPE_FILTER_KEEP_IMPORTANT);
\end{DoxyVerb}
 


\end{DoxyItemize}

 \hypertarget{a00395_upgrade_to_api_2x_xml}{}\section{X\+M\+L changes}\label{a00395_upgrade_to_api_2x_xml}
2.\+0 X\+ML files are not compatible with 1.\+x

2.\+0 can load 1.\+x files, but only N\+U\+MA distances are imported. Other distance matrices are ignored (they were never used by default anyway).

2.\+0 can export 1.\+x-\/compatible files, but only distances attached to the root object are exported (i.\+e. distances that cover the entire machine). Other distance matrices are dropped (they were never used by default anyway).

{\bfseries Users are advised to negociate hwloc versions between exporter and importer\+:} If the importer isn\textquotesingle{}t 2.\+x, the exporter should export to 1.\+x. Otherwise, things should work by default.

Hence \hyperlink{a00206_ga333f79975b4eeb28a3d8fad3373583ce}{hwloc\+\_\+topology\+\_\+export\+\_\+xml()} and \hyperlink{a00206_gad33b7f7c11db10459505a3b1634fd3f1}{hwloc\+\_\+topology\+\_\+export\+\_\+xmlbuffer()} have a new flags argument. to force a hwloc-\/1.\+x-\/compatible X\+ML export. 
\begin{DoxyItemize}
\item If both always support 2.\+0, don\textquotesingle{}t pass any flag.  
\item When the importer uses hwloc 1.\+x, export with \hyperlink{a00206_gga0eb99636aff71fe2704e1fa0ffe8c18dae7d6d96546131ef0043867b836b02e0f}{H\+W\+L\+O\+C\+\_\+\+T\+O\+P\+O\+L\+O\+G\+Y\+\_\+\+E\+X\+P\+O\+R\+T\+\_\+\+X\+M\+L\+\_\+\+F\+L\+A\+G\+\_\+\+V1}. Otherwise the importer will fail to import.  
\item When the exporter uses hwloc 1.\+x, it cannot pass any flag, and a 2.\+0 importer can import without problem.  
\end{DoxyItemize}

\begin{DoxyVerb}#if HWLOC_API_VERSION >= 0x20000
   if (need 1.x compatible XML export)
      hwloc_topology_export_xml(...., HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1);
   else /* need 2.x compatible XML export */
      hwloc_topology_export_xml(...., 0);
#else
   hwloc_topology_export_xml(....);
#endif
\end{DoxyVerb}


Additionally, \hyperlink{a00225_ga2cd902ce8766e90d4f2523a8e87640e9}{hwloc\+\_\+topology\+\_\+diff\+\_\+load\+\_\+xml()}, \hyperlink{a00225_gad693810a5c51628529b9dd56f040fb81}{hwloc\+\_\+topology\+\_\+diff\+\_\+load\+\_\+xmlbuffer()}, \hyperlink{a00225_ga8a14dd7d01efbdd97af7fe85e8b84b20}{hwloc\+\_\+topology\+\_\+diff\+\_\+export\+\_\+xml()}, \hyperlink{a00225_gaa2f0918df60c1c4a0bef9411f7d92a13}{hwloc\+\_\+topology\+\_\+diff\+\_\+export\+\_\+xmlbuffer()} and \hyperlink{a00225_ga5dcff18f80583ac6505a94ba2877fd1b}{hwloc\+\_\+topology\+\_\+diff\+\_\+destroy()} lost the topology argument\+: The first argument (topology) isn\textquotesingle{}t needed anymore.

 \hypertarget{a00395_upgrade_to_api_2x_distances}{}\section{Distances A\+P\+I totally rewritten}\label{a00395_upgrade_to_api_2x_distances}
The new distances A\+PI is in \hyperlink{a00131_source}{hwloc/distances.\+h}.

Distances are not accessible directly from objects anymore. One should first call \hyperlink{a00208_ga613e6b2a5d0f06626ee8d0c12fa46691}{hwloc\+\_\+distances\+\_\+get()} (or a variant) to retrieve distances (possibly with one call to get the number of available distances structures, and another call to actually get them). Then it may consult these structures, and finally release them.

The set of object involved in a distances structure is specified by an array of objects, it may not always cover the entire machine or so.

 \hypertarget{a00395_upgrade_to_api_2x_return}{}\section{Return values of functions}\label{a00395_upgrade_to_api_2x_return}
Bitmap functions (and a couple other functions) can return errors (in theory).

Most bitmap functions may have to reallocate the internal bitmap storage. In v1.\+x, they would silently crash if realloc failed. In v2.\+0, they now return an int that can be negative on error. However, the preallocated storage is 512 bits, hence realloc will not even be used unless you run hwloc on machines with larger PU or N\+U\+M\+Anode indexes.

\hyperlink{a00189_gace7654bb8a9002caae1a4b8a59e7452e}{hwloc\+\_\+obj\+\_\+add\+\_\+info()}, \hyperlink{a00203_gad5ee8691e08a3538ea7633344c00456d}{hwloc\+\_\+cpuset\+\_\+from\+\_\+nodeset()} and \hyperlink{a00203_gad5ee8691e08a3538ea7633344c00456d}{hwloc\+\_\+cpuset\+\_\+from\+\_\+nodeset()} also return an int, which would be -\/1 in case of allocation errors.

 \hypertarget{a00395_upgrade_to_api_2x_misc}{}\section{Misc A\+P\+I changes}\label{a00395_upgrade_to_api_2x_misc}

\begin{DoxyItemize}
\item \hyperlink{a00188_ga510f21b066fba2dab12b8c9b173b1dfd}{hwloc\+\_\+type\+\_\+sscanf()} extends hwloc\+\_\+obj\+\_\+type\+\_\+sscanf() by passing a union \hyperlink{a00242}{hwloc\+\_\+obj\+\_\+attr\+\_\+u} which may receive Cache, Group, Bridge or OS device attributes. 


\item \hyperlink{a00188_ga52c63cd7203e55b804c1314affc9bd12}{hwloc\+\_\+type\+\_\+sscanf\+\_\+as\+\_\+depth()} is also added to directly return the corresponding level depth within a topology. 


\item hwloc\+\_\+topology\+\_\+insert\+\_\+misc\+\_\+object\+\_\+by\+\_\+cpuset() is replaced with \hyperlink{a00194_ga4cea4741165faf5323931a9ed8786ef7}{hwloc\+\_\+topology\+\_\+alloc\+\_\+group\+\_\+object()} and \hyperlink{a00194_ga1fc6012b3e1c249b83f48cb7bcacaa5b}{hwloc\+\_\+topology\+\_\+insert\+\_\+group\+\_\+object()}. 


\item hwloc\+\_\+topology\+\_\+insert\+\_\+misc\+\_\+object\+\_\+by\+\_\+parent() is replaced with \hyperlink{a00194_gad980782ade737900c5cf208946768c30}{hwloc\+\_\+topology\+\_\+insert\+\_\+misc\+\_\+object()}. 


\end{DoxyItemize}

 \hypertarget{a00395_upgrade_to_api_2x_removals}{}\section{A\+P\+I removals and deprecations}\label{a00395_upgrade_to_api_2x_removals}

\begin{DoxyItemize}
\item H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+S\+Y\+S\+T\+EM removed\+: The root object is always \hyperlink{a00184_ggacd37bb612667dc437d66bfb175a8dc55a3f4e83ffc4a259354959ae8a9eaa2a80}{H\+W\+L\+O\+C\+\_\+\+O\+B\+J\+\_\+\+M\+A\+C\+H\+I\+NE} 


\item \+\_\+membind\+\_\+nodeset() memory binding interfaces deprecated\+: One should use the variant without \+\_\+nodeset suffix and pass the \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} flag. 


\item H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+R\+E\+P\+L\+I\+C\+A\+TE removed\+: no supported operating system supports it anymore. 


\item hwloc\+\_\+obj\+\_\+snprintf() removed because it was long-\/deprecated by \hyperlink{a00188_gadb8765c260edea80c52cd06a76639ba4}{hwloc\+\_\+obj\+\_\+type\+\_\+snprintf()} and \hyperlink{a00188_ga870e876931c282a1c7aee2f031912ce3}{hwloc\+\_\+obj\+\_\+attr\+\_\+snprintf()}. 


\item hwloc\+\_\+obj\+\_\+type\+\_\+sscanf() deprecated, hwloc\+\_\+obj\+\_\+type\+\_\+of\+\_\+string() removed. 


\item hwloc\+\_\+cpuset\+\_\+from/to\+\_\+nodeset\+\_\+strict() deprecated\+: Now useless since all topologies are N\+U\+MA. Use the variant without the \+\_\+strict suffix 


\item hwloc\+\_\+distribute() and hwloc\+\_\+distributev() removed, deprecated by \hyperlink{a00201_ga7b0c28f797c2ff17fa2f244ebbd55b33}{hwloc\+\_\+distrib()}. 


\item The Custom interface (hwloc\+\_\+topology\+\_\+set\+\_\+custom(), etc.) was removed, as well as the corresponding command-\/line tools (hwloc-\/assembler, etc.). Topologies always start with object with valid cpusets and nodesets. 


\item {\ttfamily obj-\/$>$online\+\_\+cpuset} removed\+: Offline P\+Us are simply listed in the {\ttfamily complete\+\_\+cpuset} as previously. 


\item {\ttfamily obj-\/$>$os\+\_\+level} removed. 


\end{DoxyItemize}