\hypertarget{a00190}{}\section{C\+PU binding}
\label{a00190}\index{C\+P\+U binding@{C\+P\+U binding}}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{a00190_ga217dc8d373f8958cc93c154ebce1c71c}{hwloc\+\_\+cpubind\+\_\+flags\+\_\+t} \{ \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71ca2e0dd0128dac6b03408c7dd170477fdc}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS}, 
\hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD}, 
\hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71ca679a7e0f0c7ee06b123565f90d98e7fa}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT}, 
\hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71ca41ce440443cc3087caed95ab60edcad6}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+N\+O\+M\+E\+M\+B\+I\+ND}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{a00190_ga80bc07473a8edf840cae17bd7ec21d48}{hwloc\+\_\+set\+\_\+cpubind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, \hyperlink{a00183_ga1f784433e9b606261f62d1134f6a3b25}{hwloc\+\_\+const\+\_\+cpuset\+\_\+t} set, int flags)
\item 
int \hyperlink{a00190_gacba7ecb979baf824d5240fa2cb2a8be6}{hwloc\+\_\+get\+\_\+cpubind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, \hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t} set, int flags)
\item 
int \hyperlink{a00190_ga296db8a3c6d49b51fb83d6f3e45c02a6}{hwloc\+\_\+set\+\_\+proc\+\_\+cpubind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, hwloc\+\_\+pid\+\_\+t pid, \hyperlink{a00183_ga1f784433e9b606261f62d1134f6a3b25}{hwloc\+\_\+const\+\_\+cpuset\+\_\+t} set, int flags)
\item 
int \hyperlink{a00190_gac82de91f788fa82dacf99c6e0d4b7158}{hwloc\+\_\+get\+\_\+proc\+\_\+cpubind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, hwloc\+\_\+pid\+\_\+t pid, \hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t} set, int flags)
\item 
int \hyperlink{a00190_gae42c01b2addcfbf6048b9a516dd7a906}{hwloc\+\_\+set\+\_\+thread\+\_\+cpubind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, hwloc\+\_\+thread\+\_\+t thread, \hyperlink{a00183_ga1f784433e9b606261f62d1134f6a3b25}{hwloc\+\_\+const\+\_\+cpuset\+\_\+t} set, int flags)
\item 
int \hyperlink{a00190_gaf13f765642b5d0d9a9813e6bb043671b}{hwloc\+\_\+get\+\_\+thread\+\_\+cpubind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, hwloc\+\_\+thread\+\_\+t thread, \hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t} set, int flags)
\item 
int \hyperlink{a00190_gafdb374627358bf09203b5a4215b13032}{hwloc\+\_\+get\+\_\+last\+\_\+cpu\+\_\+location} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, \hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t} set, int flags)
\item 
int \hyperlink{a00190_ga910a05c2d47f68a3155bf176b50fa555}{hwloc\+\_\+get\+\_\+proc\+\_\+last\+\_\+cpu\+\_\+location} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, hwloc\+\_\+pid\+\_\+t pid, \hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t} set, int flags)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Some operating systems only support binding threads or processes to a single PU. Others allow binding to larger sets such as entire Cores or Packages or even random sets of invididual P\+Us. In such operating system, the scheduler is free to run the task on one of these PU, then migrate it to another PU, etc. It is often useful to call \hyperlink{a00205_gaa611a77c092e679246afdf9a60d5db8b}{hwloc\+\_\+bitmap\+\_\+singlify()} on the target C\+PU set before passing it to the binding function to avoid these expensive migrations. See the documentation of \hyperlink{a00205_gaa611a77c092e679246afdf9a60d5db8b}{hwloc\+\_\+bitmap\+\_\+singlify()} for details.

Some operating systems do not provide all hwloc-\/supported mechanisms to bind processes, threads, etc. \hyperlink{a00193_gab8c76173c4a8ce1a9a9366012b1388e6}{hwloc\+\_\+topology\+\_\+get\+\_\+support()} may be used to query about the actual C\+PU binding support in the currently used operating system.

When the requested binding operation is not available and the \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71ca679a7e0f0c7ee06b123565f90d98e7fa}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} flag was passed, the function returns -\/1. {\ttfamily errno} is set to {\ttfamily E\+N\+O\+S\+YS} when it is not possible to bind the requested kind of object processes/threads. errno is set to {\ttfamily E\+X\+D\+EV} when the requested cpuset can not be enforced (e.\+g. some systems only allow one C\+PU, and some other systems only allow one N\+U\+MA node).

If \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71ca679a7e0f0c7ee06b123565f90d98e7fa}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} was not passed, the function may fail as well, or the operating system may use a slightly different operation (with side-\/effects, smaller binding set, etc.) when the requested operation is not exactly supported.

The most portable version that should be preferred over the others, whenever possible, is the following one which just binds the current program, assuming it is single-\/threaded\+:


\begin{DoxyCode}
\hyperlink{a00190_ga80bc07473a8edf840cae17bd7ec21d48}{hwloc\_set\_cpubind}(topology, \textcolor{keyword}{set}, 0),
\end{DoxyCode}


If the program may be multithreaded, the following one should be preferred to only bind the current thread\+:


\begin{DoxyCode}
\hyperlink{a00190_ga80bc07473a8edf840cae17bd7ec21d48}{hwloc\_set\_cpubind}(topology, \textcolor{keyword}{set}, \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421}{HWLOC\_CPUBIND\_THREAD}),
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
Some example codes are available under doc/examples/ in the source tree.
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
To unbind, just call the binding function with either a full cpuset or a cpuset equal to the system cpuset.

On some operating systems, C\+PU binding may have effects on memory binding, see \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71ca41ce440443cc3087caed95ab60edcad6}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+N\+O\+M\+E\+M\+B\+I\+ND}

Running lstopo -\/-\/top or hwloc-\/ps can be a very convenient tool to check how binding actually happened. 
\end{DoxyNote}


\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{a00190_ga217dc8d373f8958cc93c154ebce1c71c}\label{a00190_ga217dc8d373f8958cc93c154ebce1c71c}} 
\index{C\+P\+U binding@{C\+P\+U binding}!hwloc\+\_\+cpubind\+\_\+flags\+\_\+t@{hwloc\+\_\+cpubind\+\_\+flags\+\_\+t}}
\index{hwloc\+\_\+cpubind\+\_\+flags\+\_\+t@{hwloc\+\_\+cpubind\+\_\+flags\+\_\+t}!C\+P\+U binding@{C\+P\+U binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+cpubind\+\_\+flags\+\_\+t}{hwloc\_cpubind\_flags\_t}}
{\footnotesize\ttfamily enum \hyperlink{a00190_ga217dc8d373f8958cc93c154ebce1c71c}{hwloc\+\_\+cpubind\+\_\+flags\+\_\+t}}



Process/\+Thread binding flags. 

These bit flags can be used to refine the binding policy.

The default (0) is to bind the current process, assumed to be single-\/threaded, in a non-\/strict way. This is the most portable way to bind as all operating systems usually provide it.

\begin{DoxyNote}{Note}
Not all systems support all kinds of binding. See the \char`\"{}\+Detailed Description\char`\"{} section of \hyperlink{a00190}{C\+PU binding} for a description of errors that can occur. 
\end{DoxyNote}
\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS@{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS}!C\+P\+U binding@{C\+P\+U binding}}\index{C\+P\+U binding@{C\+P\+U binding}!H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS@{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS}}}\mbox{\Hypertarget{a00190_gga217dc8d373f8958cc93c154ebce1c71ca2e0dd0128dac6b03408c7dd170477fdc}\label{a00190_gga217dc8d373f8958cc93c154ebce1c71ca2e0dd0128dac6b03408c7dd170477fdc}} 
H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS&Bind all threads of the current (possibly) multithreaded process. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD@{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD}!C\+P\+U binding@{C\+P\+U binding}}\index{C\+P\+U binding@{C\+P\+U binding}!H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD@{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD}}}\mbox{\Hypertarget{a00190_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421}\label{a00190_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421}} 
H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD&Bind current thread of current process. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT@{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT}!C\+P\+U binding@{C\+P\+U binding}}\index{C\+P\+U binding@{C\+P\+U binding}!H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT@{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT}}}\mbox{\Hypertarget{a00190_gga217dc8d373f8958cc93c154ebce1c71ca679a7e0f0c7ee06b123565f90d98e7fa}\label{a00190_gga217dc8d373f8958cc93c154ebce1c71ca679a7e0f0c7ee06b123565f90d98e7fa}} 
H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT&Request for strict binding from the OS. By default, when the designated C\+P\+Us are all busy while other C\+P\+Us are idle, operating systems may execute the thread/process on those other C\+P\+Us instead of the designated C\+P\+Us, to let them progress anyway. Strict binding means that the thread/process will \+\_\+never\+\_\+ execute on other cpus than the designated C\+P\+Us, even when those are busy with other tasks and other C\+P\+Us are idle.

\begin{DoxyNote}{Note}
Depending on the operating system, strict binding may not be possible (e.\+g., the OS does not implement it) or not allowed (e.\+g., for an administrative reasons), and the function will fail in that case.
\end{DoxyNote}
When retrieving the binding of a process, this flag checks whether all its threads actually have the same binding. If the flag is not given, the binding of each thread will be accumulated.

\begin{DoxyNote}{Note}
This flag is meaningless when retrieving the binding of a thread. 
\end{DoxyNote}
\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+N\+O\+M\+E\+M\+B\+I\+ND@{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+N\+O\+M\+E\+M\+B\+I\+ND}!C\+P\+U binding@{C\+P\+U binding}}\index{C\+P\+U binding@{C\+P\+U binding}!H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+N\+O\+M\+E\+M\+B\+I\+ND@{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+N\+O\+M\+E\+M\+B\+I\+ND}}}\mbox{\Hypertarget{a00190_gga217dc8d373f8958cc93c154ebce1c71ca41ce440443cc3087caed95ab60edcad6}\label{a00190_gga217dc8d373f8958cc93c154ebce1c71ca41ce440443cc3087caed95ab60edcad6}} 
H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+N\+O\+M\+E\+M\+B\+I\+ND&Avoid any effect on memory binding. On some operating systems, some C\+PU binding function would also bind the memory on the corresponding N\+U\+MA node. It is often not a problem for the application, but if it is, setting this flag will make hwloc avoid using OS functions that would also bind memory. This will however reduce the support of C\+PU bindings, i.\+e. potentially return -\/1 with errno set to E\+N\+O\+S\+YS in some cases.

This flag is only meaningful when used with functions that set the C\+PU binding. It is ignored when used with functions that get C\+PU binding information. \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\Hypertarget{a00190_gacba7ecb979baf824d5240fa2cb2a8be6}\label{a00190_gacba7ecb979baf824d5240fa2cb2a8be6}} 
\index{C\+P\+U binding@{C\+P\+U binding}!hwloc\+\_\+get\+\_\+cpubind@{hwloc\+\_\+get\+\_\+cpubind}}
\index{hwloc\+\_\+get\+\_\+cpubind@{hwloc\+\_\+get\+\_\+cpubind}!C\+P\+U binding@{C\+P\+U binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+get\+\_\+cpubind()}{hwloc\_get\_cpubind()}}
{\footnotesize\ttfamily int hwloc\+\_\+get\+\_\+cpubind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{\hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t}}]{set,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Get current process or thread binding. 

Writes into {\ttfamily set} the physical cpuset which the process or thread (according to {\itshape flags}) was last bound to. \mbox{\Hypertarget{a00190_gafdb374627358bf09203b5a4215b13032}\label{a00190_gafdb374627358bf09203b5a4215b13032}} 
\index{C\+P\+U binding@{C\+P\+U binding}!hwloc\+\_\+get\+\_\+last\+\_\+cpu\+\_\+location@{hwloc\+\_\+get\+\_\+last\+\_\+cpu\+\_\+location}}
\index{hwloc\+\_\+get\+\_\+last\+\_\+cpu\+\_\+location@{hwloc\+\_\+get\+\_\+last\+\_\+cpu\+\_\+location}!C\+P\+U binding@{C\+P\+U binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+get\+\_\+last\+\_\+cpu\+\_\+location()}{hwloc\_get\_last\_cpu\_location()}}
{\footnotesize\ttfamily int hwloc\+\_\+get\+\_\+last\+\_\+cpu\+\_\+location (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{\hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t}}]{set,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Get the last physical C\+PU where the current process or thread ran. 

The operating system may move some tasks from one processor to another at any time according to their binding, so this function may return something that is already outdated.

{\ttfamily flags} can include either \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71ca2e0dd0128dac6b03408c7dd170477fdc}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} or \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} to specify whether the query should be for the whole process (union of all C\+P\+Us on which all threads are running), or only the current thread. If the process is single-\/threaded, flags can be set to zero to let hwloc use whichever method is available on the underlying OS. \mbox{\Hypertarget{a00190_gac82de91f788fa82dacf99c6e0d4b7158}\label{a00190_gac82de91f788fa82dacf99c6e0d4b7158}} 
\index{C\+P\+U binding@{C\+P\+U binding}!hwloc\+\_\+get\+\_\+proc\+\_\+cpubind@{hwloc\+\_\+get\+\_\+proc\+\_\+cpubind}}
\index{hwloc\+\_\+get\+\_\+proc\+\_\+cpubind@{hwloc\+\_\+get\+\_\+proc\+\_\+cpubind}!C\+P\+U binding@{C\+P\+U binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+get\+\_\+proc\+\_\+cpubind()}{hwloc\_get\_proc\_cpubind()}}
{\footnotesize\ttfamily int hwloc\+\_\+get\+\_\+proc\+\_\+cpubind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{hwloc\+\_\+pid\+\_\+t}]{pid,  }\item[{\hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t}}]{set,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Get the current physical binding of process {\ttfamily pid}. 

\begin{DoxyNote}{Note}
{\ttfamily hwloc\+\_\+pid\+\_\+t} is {\ttfamily pid\+\_\+t} on Unix platforms, and {\ttfamily H\+A\+N\+D\+LE} on native Windows platforms.

As a special case on Linux, if a tid (thread ID) is supplied instead of a pid (process ID) and H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD is passed in flags, the binding for that specific thread is returned.

On non-\/\+Linux systems, H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD can not be used in {\ttfamily flags}. 
\end{DoxyNote}
\mbox{\Hypertarget{a00190_ga910a05c2d47f68a3155bf176b50fa555}\label{a00190_ga910a05c2d47f68a3155bf176b50fa555}} 
\index{C\+P\+U binding@{C\+P\+U binding}!hwloc\+\_\+get\+\_\+proc\+\_\+last\+\_\+cpu\+\_\+location@{hwloc\+\_\+get\+\_\+proc\+\_\+last\+\_\+cpu\+\_\+location}}
\index{hwloc\+\_\+get\+\_\+proc\+\_\+last\+\_\+cpu\+\_\+location@{hwloc\+\_\+get\+\_\+proc\+\_\+last\+\_\+cpu\+\_\+location}!C\+P\+U binding@{C\+P\+U binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+get\+\_\+proc\+\_\+last\+\_\+cpu\+\_\+location()}{hwloc\_get\_proc\_last\_cpu\_location()}}
{\footnotesize\ttfamily int hwloc\+\_\+get\+\_\+proc\+\_\+last\+\_\+cpu\+\_\+location (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{hwloc\+\_\+pid\+\_\+t}]{pid,  }\item[{\hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t}}]{set,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Get the last physical C\+PU where a process ran. 

The operating system may move some tasks from one processor to another at any time according to their binding, so this function may return something that is already outdated.

\begin{DoxyNote}{Note}
{\ttfamily hwloc\+\_\+pid\+\_\+t} is {\ttfamily pid\+\_\+t} on Unix platforms, and {\ttfamily H\+A\+N\+D\+LE} on native Windows platforms.

As a special case on Linux, if a tid (thread ID) is supplied instead of a pid (process ID) and \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} is passed in flags, the last C\+PU location of that specific thread is returned.

On non-\/\+Linux systems, \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} can not be used in {\ttfamily flags}. 
\end{DoxyNote}
\mbox{\Hypertarget{a00190_gaf13f765642b5d0d9a9813e6bb043671b}\label{a00190_gaf13f765642b5d0d9a9813e6bb043671b}} 
\index{C\+P\+U binding@{C\+P\+U binding}!hwloc\+\_\+get\+\_\+thread\+\_\+cpubind@{hwloc\+\_\+get\+\_\+thread\+\_\+cpubind}}
\index{hwloc\+\_\+get\+\_\+thread\+\_\+cpubind@{hwloc\+\_\+get\+\_\+thread\+\_\+cpubind}!C\+P\+U binding@{C\+P\+U binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+get\+\_\+thread\+\_\+cpubind()}{hwloc\_get\_thread\_cpubind()}}
{\footnotesize\ttfamily int hwloc\+\_\+get\+\_\+thread\+\_\+cpubind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{hwloc\+\_\+thread\+\_\+t}]{thread,  }\item[{\hyperlink{a00183_ga4bbf39b68b6f568fb92739e7c0ea7801}{hwloc\+\_\+cpuset\+\_\+t}}]{set,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Get the current physical binding of thread {\ttfamily tid}. 

\begin{DoxyNote}{Note}
{\ttfamily hwloc\+\_\+thread\+\_\+t} is {\ttfamily pthread\+\_\+t} on Unix platforms, and {\ttfamily H\+A\+N\+D\+LE} on native Windows platforms.

\hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71ca2e0dd0128dac6b03408c7dd170477fdc}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} can not be used in {\ttfamily flags}. 
\end{DoxyNote}
\mbox{\Hypertarget{a00190_ga80bc07473a8edf840cae17bd7ec21d48}\label{a00190_ga80bc07473a8edf840cae17bd7ec21d48}} 
\index{C\+P\+U binding@{C\+P\+U binding}!hwloc\+\_\+set\+\_\+cpubind@{hwloc\+\_\+set\+\_\+cpubind}}
\index{hwloc\+\_\+set\+\_\+cpubind@{hwloc\+\_\+set\+\_\+cpubind}!C\+P\+U binding@{C\+P\+U binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+set\+\_\+cpubind()}{hwloc\_set\_cpubind()}}
{\footnotesize\ttfamily int hwloc\+\_\+set\+\_\+cpubind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{\hyperlink{a00183_ga1f784433e9b606261f62d1134f6a3b25}{hwloc\+\_\+const\+\_\+cpuset\+\_\+t}}]{set,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Bind current process or thread on cpus given in physical bitmap {\ttfamily set}. 

\begin{DoxyReturn}{Returns}
-\/1 with errno set to E\+N\+O\+S\+YS if the action is not supported 

-\/1 with errno set to E\+X\+D\+EV if the binding cannot be enforced 
\end{DoxyReturn}
\mbox{\Hypertarget{a00190_ga296db8a3c6d49b51fb83d6f3e45c02a6}\label{a00190_ga296db8a3c6d49b51fb83d6f3e45c02a6}} 
\index{C\+P\+U binding@{C\+P\+U binding}!hwloc\+\_\+set\+\_\+proc\+\_\+cpubind@{hwloc\+\_\+set\+\_\+proc\+\_\+cpubind}}
\index{hwloc\+\_\+set\+\_\+proc\+\_\+cpubind@{hwloc\+\_\+set\+\_\+proc\+\_\+cpubind}!C\+P\+U binding@{C\+P\+U binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+set\+\_\+proc\+\_\+cpubind()}{hwloc\_set\_proc\_cpubind()}}
{\footnotesize\ttfamily int hwloc\+\_\+set\+\_\+proc\+\_\+cpubind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{hwloc\+\_\+pid\+\_\+t}]{pid,  }\item[{\hyperlink{a00183_ga1f784433e9b606261f62d1134f6a3b25}{hwloc\+\_\+const\+\_\+cpuset\+\_\+t}}]{set,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Bind a process {\ttfamily pid} on cpus given in physical bitmap {\ttfamily set}. 

\begin{DoxyNote}{Note}
{\ttfamily hwloc\+\_\+pid\+\_\+t} is {\ttfamily pid\+\_\+t} on Unix platforms, and {\ttfamily H\+A\+N\+D\+LE} on native Windows platforms.

As a special case on Linux, if a tid (thread ID) is supplied instead of a pid (process ID) and \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} is passed in flags, the binding is applied to that specific thread.

On non-\/\+Linux systems, \hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71caf1b6bbad00d7b1017b918e3719f4d421}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} can not be used in {\ttfamily flags}. 
\end{DoxyNote}
\mbox{\Hypertarget{a00190_gae42c01b2addcfbf6048b9a516dd7a906}\label{a00190_gae42c01b2addcfbf6048b9a516dd7a906}} 
\index{C\+P\+U binding@{C\+P\+U binding}!hwloc\+\_\+set\+\_\+thread\+\_\+cpubind@{hwloc\+\_\+set\+\_\+thread\+\_\+cpubind}}
\index{hwloc\+\_\+set\+\_\+thread\+\_\+cpubind@{hwloc\+\_\+set\+\_\+thread\+\_\+cpubind}!C\+P\+U binding@{C\+P\+U binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+set\+\_\+thread\+\_\+cpubind()}{hwloc\_set\_thread\_cpubind()}}
{\footnotesize\ttfamily int hwloc\+\_\+set\+\_\+thread\+\_\+cpubind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{hwloc\+\_\+thread\+\_\+t}]{thread,  }\item[{\hyperlink{a00183_ga1f784433e9b606261f62d1134f6a3b25}{hwloc\+\_\+const\+\_\+cpuset\+\_\+t}}]{set,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Bind a thread {\ttfamily thread} on cpus given in physical bitmap {\ttfamily set}. 

\begin{DoxyNote}{Note}
{\ttfamily hwloc\+\_\+thread\+\_\+t} is {\ttfamily pthread\+\_\+t} on Unix platforms, and {\ttfamily H\+A\+N\+D\+LE} on native Windows platforms.

\hyperlink{a00190_gga217dc8d373f8958cc93c154ebce1c71ca2e0dd0128dac6b03408c7dd170477fdc}{H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} can not be used in {\ttfamily flags}. 
\end{DoxyNote}
