\hypertarget{a00191}{}\section{Memory binding}
\label{a00191}\index{Memory binding@{Memory binding}}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} \{ \newline
\hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8a18675bb80ebc1bce5b652e9de8f3998c}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+D\+E\+F\+A\+U\+LT}, 
\hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8a979c7aa78dd32780858f30f47a72cca0}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+F\+I\+R\+S\+T\+T\+O\+U\+CH}, 
\hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8ad811fa4b2a6002c4d63695a408ffde2c}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+I\+ND}, 
\hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8ae370075e5af016d42310f87ea5af236b}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+I\+N\+T\+E\+R\+L\+E\+A\+VE}, 
\newline
\hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8aecdd4164d647708fbb51a00d98dbb138}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+E\+X\+T\+T\+O\+U\+CH}, 
\hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8a3185bd869b67817fb2bd5164bf360402}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+X\+ED}
 \}
\item 
enum \hyperlink{a00191_gab00475fd98815bf4fb9aaf752030e7d2}{hwloc\+\_\+membind\+\_\+flags\+\_\+t} \{ \newline
\hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS}, 
\hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD}, 
\hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT}, 
\hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2aa6e49e54f52827cb143cc869cfd748af}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+G\+R\+A\+TE}, 
\newline
\hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2aad6b9eaf2ee324ca58dc8f58094b9997}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+O\+C\+P\+U\+B\+I\+ND}, 
\hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{a00191_ga020951efa0ce3862bd4faec295501a7f}{hwloc\+\_\+set\+\_\+membind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, \hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t} set, \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} policy, int flags)
\item 
int \hyperlink{a00191_gae21f0a1a884929c784bebf070252aa56}{hwloc\+\_\+get\+\_\+membind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, \hyperlink{a00205_gaa3c2bf4c776d603dcebbb61b0c923d84}{hwloc\+\_\+bitmap\+\_\+t} set, \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} $\ast$policy, int flags)
\item 
int \hyperlink{a00191_gabc91ff16f7e41047924e3a4ae6d9da7e}{hwloc\+\_\+set\+\_\+proc\+\_\+membind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, hwloc\+\_\+pid\+\_\+t pid, \hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t} set, \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} policy, int flags)
\item 
int \hyperlink{a00191_ga1730ceb18ec6ee3b7bd3d0db81f07dc8}{hwloc\+\_\+get\+\_\+proc\+\_\+membind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, hwloc\+\_\+pid\+\_\+t pid, \hyperlink{a00205_gaa3c2bf4c776d603dcebbb61b0c923d84}{hwloc\+\_\+bitmap\+\_\+t} set, \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} $\ast$policy, int flags)
\item 
int \hyperlink{a00191_gaf881faefe20701229f07dd7dbd0125ed}{hwloc\+\_\+set\+\_\+area\+\_\+membind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, const void $\ast$addr, size\+\_\+t len, \hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t} set, \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} policy, int flags)
\item 
int \hyperlink{a00191_gaa87e0a6946ff145914fdf0b1c60567f8}{hwloc\+\_\+get\+\_\+area\+\_\+membind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, const void $\ast$addr, size\+\_\+t len, \hyperlink{a00205_gaa3c2bf4c776d603dcebbb61b0c923d84}{hwloc\+\_\+bitmap\+\_\+t} set, \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} $\ast$policy, int flags)
\item 
int \hyperlink{a00191_ga537c7508a4e2d1db05673ec5be6e805c}{hwloc\+\_\+get\+\_\+area\+\_\+memlocation} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, const void $\ast$addr, size\+\_\+t len, \hyperlink{a00205_gaa3c2bf4c776d603dcebbb61b0c923d84}{hwloc\+\_\+bitmap\+\_\+t} set, int flags)
\item 
void $\ast$ \hyperlink{a00191_ga972b335a86a7d5e7b34bce2b243c41bc}{hwloc\+\_\+alloc} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, size\+\_\+t len)
\item 
void $\ast$ \hyperlink{a00191_ga04736461780fadcf193af218c0122273}{hwloc\+\_\+alloc\+\_\+membind} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, size\+\_\+t len, \hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t} set, \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} policy, int flags)
\item 
static void $\ast$ \hyperlink{a00191_gab1b77b8408bacaf03c7e8878f7577922}{hwloc\+\_\+alloc\+\_\+membind\+\_\+policy} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, size\+\_\+t len, \hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t} set, \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} policy, int flags)
\item 
int \hyperlink{a00191_ga32dbd4f54e9e4a7179f2dde37ffe6ad7}{hwloc\+\_\+free} (\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t} topology, void $\ast$addr, size\+\_\+t len)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Memory binding can be done three ways\+:


\begin{DoxyItemize}
\item explicit memory allocation thanks to \hyperlink{a00191_ga04736461780fadcf193af218c0122273}{hwloc\+\_\+alloc\+\_\+membind()} and friends\+: the binding will have effect on the memory allocated by these functions.
\item implicit memory binding through binding policy\+: \hyperlink{a00191_ga020951efa0ce3862bd4faec295501a7f}{hwloc\+\_\+set\+\_\+membind()} and friends only define the current policy of the process, which will be applied to the subsequent calls to malloc() and friends.
\item migration of existing memory ranges, thanks to \hyperlink{a00191_gaf881faefe20701229f07dd7dbd0125ed}{hwloc\+\_\+set\+\_\+area\+\_\+membind()} and friends, which move already-\/allocated data.
\end{DoxyItemize}

Not all operating systems support all three ways. \hyperlink{a00193_gab8c76173c4a8ce1a9a9366012b1388e6}{hwloc\+\_\+topology\+\_\+get\+\_\+support()} may be used to query about the actual memory binding support in the currently used operating system.

When the requested binding operation is not available and the \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} flag was passed, the function returns -\/1. {\ttfamily errno} will be set to {\ttfamily E\+N\+O\+S\+YS} when the system does support the specified action or policy (e.\+g., some systems only allow binding memory on a per-\/thread basis, whereas other systems only allow binding memory for all threads in a process). {\ttfamily errno} will be set to E\+X\+D\+EV when the requested set can not be enforced (e.\+g., some systems only allow binding memory to a single N\+U\+MA node).

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} was not passed, the function may fail as well, or the operating system may use a slightly different operation (with side-\/effects, smaller binding set, etc.) when the requested operation is not exactly supported.

The most portable form that should be preferred over the others whenever possible is as follows. It allocates some memory hopefully bound to the specified set. To do so, hwloc will possibly have to change the current memory binding policy in order to actually get the memory bound, if the OS does not provide any other way to simply allocate bound memory without changing the policy for all allocations. That is the difference with \hyperlink{a00191_ga04736461780fadcf193af218c0122273}{hwloc\+\_\+alloc\+\_\+membind()}, which will never change the current memory binding policy.


\begin{DoxyCode}
\hyperlink{a00191_gab1b77b8408bacaf03c7e8878f7577922}{hwloc\_alloc\_membind\_policy}(topology, size, \textcolor{keyword}{set},
                           \hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8ad811fa4b2a6002c4d63695a408ffde2c}{HWLOC\_MEMBIND\_BIND}, 0);
\end{DoxyCode}


Each hwloc memory binding function takes a bitmap argument that is a C\+PU set by default, or a N\+U\+MA memory node set if the flag \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified. See \hyperlink{a00183}{Object Sets (hwloc\+\_\+cpuset\+\_\+t and hwloc\+\_\+nodeset\+\_\+t)} and \hyperlink{a00205}{The bitmap A\+PI} for a discussion of C\+PU sets and N\+U\+MA memory node sets. It is also possible to convert between C\+PU set and node set using \hyperlink{a00203_ga185751c1653fedbeb7cc480840f38cde}{hwloc\+\_\+cpuset\+\_\+to\+\_\+nodeset()} or \hyperlink{a00203_gad5ee8691e08a3538ea7633344c00456d}{hwloc\+\_\+cpuset\+\_\+from\+\_\+nodeset()}.

Memory binding by C\+PU set cannot work for C\+P\+U-\/less N\+U\+MA memory nodes. Binding by nodeset should therefore be preferred whenever possible.

\begin{DoxySeeAlso}{See also}
Some example codes are available under doc/examples/ in the source tree.
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
On some operating systems, memory binding affects the C\+PU binding; see \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2aad6b9eaf2ee324ca58dc8f58094b9997}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+O\+C\+P\+U\+B\+I\+ND} 
\end{DoxyNote}


\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{a00191_gab00475fd98815bf4fb9aaf752030e7d2}\label{a00191_gab00475fd98815bf4fb9aaf752030e7d2}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+membind\+\_\+flags\+\_\+t@{hwloc\+\_\+membind\+\_\+flags\+\_\+t}}
\index{hwloc\+\_\+membind\+\_\+flags\+\_\+t@{hwloc\+\_\+membind\+\_\+flags\+\_\+t}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+membind\+\_\+flags\+\_\+t}{hwloc\_membind\_flags\_t}}
{\footnotesize\ttfamily enum \hyperlink{a00191_gab00475fd98815bf4fb9aaf752030e7d2}{hwloc\+\_\+membind\+\_\+flags\+\_\+t}}



Memory binding flags. 

These flags can be used to refine the binding policy. All flags can be logically OR\textquotesingle{}ed together with the exception of \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} and \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD}; these two flags are mutually exclusive.

Not all systems support all kinds of binding. \hyperlink{a00193_gab8c76173c4a8ce1a9a9366012b1388e6}{hwloc\+\_\+topology\+\_\+get\+\_\+support()} may be used to query about the actual memory binding support in the currently used operating system. See the \char`\"{}\+Detailed Description\char`\"{} section of \hyperlink{a00191}{Memory binding} for a description of errors that can occur. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS}}}\mbox{\Hypertarget{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}\label{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS&Set policy for all threads of the specified (possibly multithreaded) process. This flag is mutually exclusive with \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD}. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD}}}\mbox{\Hypertarget{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}\label{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD&Set policy for a specific thread of the current process. This flag is mutually exclusive with \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS}. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT}}}\mbox{\Hypertarget{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}\label{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT&Request strict binding from the OS. The function will fail if the binding can not be guaranteed / completely enforced.

This flag has slightly different meanings depending on which function it is used with. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+G\+R\+A\+TE@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+G\+R\+A\+TE}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+G\+R\+A\+TE@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+G\+R\+A\+TE}}}\mbox{\Hypertarget{a00191_ggab00475fd98815bf4fb9aaf752030e7d2aa6e49e54f52827cb143cc869cfd748af}\label{a00191_ggab00475fd98815bf4fb9aaf752030e7d2aa6e49e54f52827cb143cc869cfd748af}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+G\+R\+A\+TE&Migrate existing allocated memory. If the memory cannot be migrated and the \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} flag is passed, an error will be returned. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+O\+C\+P\+U\+B\+I\+ND@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+O\+C\+P\+U\+B\+I\+ND}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+O\+C\+P\+U\+B\+I\+ND@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+O\+C\+P\+U\+B\+I\+ND}}}\mbox{\Hypertarget{a00191_ggab00475fd98815bf4fb9aaf752030e7d2aad6b9eaf2ee324ca58dc8f58094b9997}\label{a00191_ggab00475fd98815bf4fb9aaf752030e7d2aad6b9eaf2ee324ca58dc8f58094b9997}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+O\+C\+P\+U\+B\+I\+ND&Avoid any effect on C\+PU binding. On some operating systems, some underlying memory binding functions also bind the application to the corresponding C\+P\+U(s). Using this flag will cause hwloc to avoid using OS functions that could potentially affect C\+PU bindings. Note, however, that using N\+O\+C\+P\+U\+B\+I\+ND may reduce hwloc\textquotesingle{}s overall memory binding support. Specifically\+: some of hwloc\textquotesingle{}s memory binding functions may fail with errno set to E\+N\+O\+S\+YS when used with N\+O\+C\+P\+U\+B\+I\+ND. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET}}}\mbox{\Hypertarget{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}\label{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET&Consider the bitmap argument as a nodeset. The bitmap argument is considered a nodeset if this flag is given, or a cpuset otherwise by default.

Memory binding by C\+PU set cannot work for C\+P\+U-\/less N\+U\+MA memory nodes. Binding by nodeset should therefore be preferred whenever possible. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{a00191_gac9764f79505775d06407b40f5e4661e8}\label{a00191_gac9764f79505775d06407b40f5e4661e8}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+membind\+\_\+policy\+\_\+t@{hwloc\+\_\+membind\+\_\+policy\+\_\+t}}
\index{hwloc\+\_\+membind\+\_\+policy\+\_\+t@{hwloc\+\_\+membind\+\_\+policy\+\_\+t}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+membind\+\_\+policy\+\_\+t}{hwloc\_membind\_policy\_t}}
{\footnotesize\ttfamily enum \hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t}}



Memory binding policy. 

These constants can be used to choose the binding policy. Only one policy can be used at a time (i.\+e., the values cannot be OR\textquotesingle{}ed together).

Not all systems support all kinds of binding. \hyperlink{a00193_gab8c76173c4a8ce1a9a9366012b1388e6}{hwloc\+\_\+topology\+\_\+get\+\_\+support()} may be used to query about the actual memory binding policy support in the currently used operating system. See the \char`\"{}\+Detailed Description\char`\"{} section of \hyperlink{a00191}{Memory binding} for a description of errors that can occur. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+D\+E\+F\+A\+U\+LT@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+D\+E\+F\+A\+U\+LT}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+D\+E\+F\+A\+U\+LT@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+D\+E\+F\+A\+U\+LT}}}\mbox{\Hypertarget{a00191_ggac9764f79505775d06407b40f5e4661e8a18675bb80ebc1bce5b652e9de8f3998c}\label{a00191_ggac9764f79505775d06407b40f5e4661e8a18675bb80ebc1bce5b652e9de8f3998c}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+D\+E\+F\+A\+U\+LT&Reset the memory allocation policy to the system default. Depending on the operating system, this may correspond to \hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8a979c7aa78dd32780858f30f47a72cca0}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+F\+I\+R\+S\+T\+T\+O\+U\+CH} (Linux, Free\+B\+SD), or \hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8ad811fa4b2a6002c4d63695a408ffde2c}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+I\+ND} (A\+IX, H\+P-\/\+UX, Solaris, Windows). This policy is never returned by get membind functions. The nodeset argument is ignored. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+F\+I\+R\+S\+T\+T\+O\+U\+CH@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+F\+I\+R\+S\+T\+T\+O\+U\+CH}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+F\+I\+R\+S\+T\+T\+O\+U\+CH@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+F\+I\+R\+S\+T\+T\+O\+U\+CH}}}\mbox{\Hypertarget{a00191_ggac9764f79505775d06407b40f5e4661e8a979c7aa78dd32780858f30f47a72cca0}\label{a00191_ggac9764f79505775d06407b40f5e4661e8a979c7aa78dd32780858f30f47a72cca0}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+F\+I\+R\+S\+T\+T\+O\+U\+CH&Allocate each memory page individually on the local N\+U\+MA node of the thread that touches it. The given nodeset should usually be \hyperlink{a00202_ga3fd37303e99ace8b0d0ea03f95f8c514}{hwloc\+\_\+topology\+\_\+get\+\_\+topology\+\_\+nodeset()} so that the touching thread may run and allocate on any node in the system.

On A\+IX, if the nodeset is smaller, pages are allocated locally (if the local node is in the nodeset) or from a random non-\/local node (otherwise). \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+I\+ND@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+I\+ND}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+I\+ND@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+I\+ND}}}\mbox{\Hypertarget{a00191_ggac9764f79505775d06407b40f5e4661e8ad811fa4b2a6002c4d63695a408ffde2c}\label{a00191_ggac9764f79505775d06407b40f5e4661e8ad811fa4b2a6002c4d63695a408ffde2c}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+I\+ND&Allocate memory on the specified nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+I\+N\+T\+E\+R\+L\+E\+A\+VE@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+I\+N\+T\+E\+R\+L\+E\+A\+VE}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+I\+N\+T\+E\+R\+L\+E\+A\+VE@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+I\+N\+T\+E\+R\+L\+E\+A\+VE}}}\mbox{\Hypertarget{a00191_ggac9764f79505775d06407b40f5e4661e8ae370075e5af016d42310f87ea5af236b}\label{a00191_ggac9764f79505775d06407b40f5e4661e8ae370075e5af016d42310f87ea5af236b}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+I\+N\+T\+E\+R\+L\+E\+A\+VE&Allocate memory on the given nodes in an interleaved / round-\/robin manner. The precise layout of the memory across multiple N\+U\+MA nodes is O\+S/system specific. Interleaving can be useful when threads distributed across the specified N\+U\+MA nodes will all be accessing the whole memory range concurrently, since the interleave will then balance the memory references. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+E\+X\+T\+T\+O\+U\+CH@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+E\+X\+T\+T\+O\+U\+CH}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+E\+X\+T\+T\+O\+U\+CH@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+E\+X\+T\+T\+O\+U\+CH}}}\mbox{\Hypertarget{a00191_ggac9764f79505775d06407b40f5e4661e8aecdd4164d647708fbb51a00d98dbb138}\label{a00191_ggac9764f79505775d06407b40f5e4661e8aecdd4164d647708fbb51a00d98dbb138}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+N\+E\+X\+T\+T\+O\+U\+CH&For each page bound with this policy, by next time it is touched (and next time only), it is moved from its current location to the local N\+U\+MA node of the thread where the memory reference occurred (if it needs to be moved at all). \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+X\+ED@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+X\+ED}!Memory binding@{Memory binding}}\index{Memory binding@{Memory binding}!H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+X\+ED@{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+X\+ED}}}\mbox{\Hypertarget{a00191_ggac9764f79505775d06407b40f5e4661e8a3185bd869b67817fb2bd5164bf360402}\label{a00191_ggac9764f79505775d06407b40f5e4661e8a3185bd869b67817fb2bd5164bf360402}} 
H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+X\+ED&Returned by get\+\_\+membind() functions when multiple threads or parts of a memory area have differing memory binding policies. Also returned when binding is unknown because binding hooks are empty when the topology is loaded from X\+ML without H\+W\+L\+O\+C\+\_\+\+T\+H\+I\+S\+S\+Y\+S\+T\+EM=1, etc. \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\Hypertarget{a00191_ga972b335a86a7d5e7b34bce2b243c41bc}\label{a00191_ga972b335a86a7d5e7b34bce2b243c41bc}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+alloc@{hwloc\+\_\+alloc}}
\index{hwloc\+\_\+alloc@{hwloc\+\_\+alloc}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+alloc()}{hwloc\_alloc()}}
{\footnotesize\ttfamily void$\ast$ hwloc\+\_\+alloc (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}



Allocate some memory. 

This is equivalent to malloc(), except that it tries to allocate page-\/aligned memory from the OS.

\begin{DoxyNote}{Note}
The allocated memory should be freed with \hyperlink{a00191_ga32dbd4f54e9e4a7179f2dde37ffe6ad7}{hwloc\+\_\+free()}. 
\end{DoxyNote}
\mbox{\Hypertarget{a00191_ga04736461780fadcf193af218c0122273}\label{a00191_ga04736461780fadcf193af218c0122273}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+alloc\+\_\+membind@{hwloc\+\_\+alloc\+\_\+membind}}
\index{hwloc\+\_\+alloc\+\_\+membind@{hwloc\+\_\+alloc\+\_\+membind}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+alloc\+\_\+membind()}{hwloc\_alloc\_membind()}}
{\footnotesize\ttfamily void$\ast$ hwloc\+\_\+alloc\+\_\+membind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{size\+\_\+t}]{len,  }\item[{\hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t}}]{set,  }\item[{\hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t}}]{policy,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Allocate some memory on N\+U\+MA memory nodes specified by {\ttfamily set}. 

\begin{DoxyReturn}{Returns}
N\+U\+LL with errno set to E\+N\+O\+S\+YS if the action is not supported and \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} is given 

N\+U\+LL with errno set to E\+X\+D\+EV if the binding cannot be enforced and \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} is given 

N\+U\+LL with errno set to E\+N\+O\+M\+EM if the memory allocation failed even before trying to bind.
\end{DoxyReturn}
If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified, set is considered a nodeset. Otherwise it\textquotesingle{}s a cpuset.

\begin{DoxyNote}{Note}
The allocated memory should be freed with \hyperlink{a00191_ga32dbd4f54e9e4a7179f2dde37ffe6ad7}{hwloc\+\_\+free()}. 
\end{DoxyNote}
\mbox{\Hypertarget{a00191_gab1b77b8408bacaf03c7e8878f7577922}\label{a00191_gab1b77b8408bacaf03c7e8878f7577922}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+alloc\+\_\+membind\+\_\+policy@{hwloc\+\_\+alloc\+\_\+membind\+\_\+policy}}
\index{hwloc\+\_\+alloc\+\_\+membind\+\_\+policy@{hwloc\+\_\+alloc\+\_\+membind\+\_\+policy}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+alloc\+\_\+membind\+\_\+policy()}{hwloc\_alloc\_membind\_policy()}}
{\footnotesize\ttfamily static void$\ast$ hwloc\+\_\+alloc\+\_\+membind\+\_\+policy (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{size\+\_\+t}]{len,  }\item[{\hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t}}]{set,  }\item[{\hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t}}]{policy,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Allocate some memory on N\+U\+MA memory nodes specified by {\ttfamily set}. 

This is similar to hwloc\+\_\+alloc\+\_\+membind\+\_\+nodeset() except that it is allowed to change the current memory binding policy, thus providing more binding support, at the expense of changing the current state.

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified, set is considered a nodeset. Otherwise it\textquotesingle{}s a cpuset. \mbox{\Hypertarget{a00191_ga32dbd4f54e9e4a7179f2dde37ffe6ad7}\label{a00191_ga32dbd4f54e9e4a7179f2dde37ffe6ad7}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+free@{hwloc\+\_\+free}}
\index{hwloc\+\_\+free@{hwloc\+\_\+free}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+free()}{hwloc\_free()}}
{\footnotesize\ttfamily int hwloc\+\_\+free (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{void $\ast$}]{addr,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}



Free memory that was previously allocated by \hyperlink{a00191_ga972b335a86a7d5e7b34bce2b243c41bc}{hwloc\+\_\+alloc()} or \hyperlink{a00191_ga04736461780fadcf193af218c0122273}{hwloc\+\_\+alloc\+\_\+membind()}. 

\mbox{\Hypertarget{a00191_gaa87e0a6946ff145914fdf0b1c60567f8}\label{a00191_gaa87e0a6946ff145914fdf0b1c60567f8}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+get\+\_\+area\+\_\+membind@{hwloc\+\_\+get\+\_\+area\+\_\+membind}}
\index{hwloc\+\_\+get\+\_\+area\+\_\+membind@{hwloc\+\_\+get\+\_\+area\+\_\+membind}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+get\+\_\+area\+\_\+membind()}{hwloc\_get\_area\_membind()}}
{\footnotesize\ttfamily int hwloc\+\_\+get\+\_\+area\+\_\+membind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{const void $\ast$}]{addr,  }\item[{size\+\_\+t}]{len,  }\item[{\hyperlink{a00205_gaa3c2bf4c776d603dcebbb61b0c923d84}{hwloc\+\_\+bitmap\+\_\+t}}]{set,  }\item[{\hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} $\ast$}]{policy,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Query the C\+P\+Us near the physical N\+U\+MA node(s) and binding policy of the memory identified by ({\ttfamily addr}, {\ttfamily len} ). 

This function has two output parameters\+: {\ttfamily set} and {\ttfamily policy}. The values returned in these parameters depend on both the {\ttfamily flags} passed in and the memory binding policies and nodesets of the pages in the address range.

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} is specified, the target pages are first checked to see if they all have the same memory binding policy and nodeset. If they do not, -\/1 is returned and errno is set to E\+X\+D\+EV. If they are identical across all pages, the set and policy are returned in {\ttfamily set} and {\ttfamily policy}, respectively.

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} is not specified, the union of all N\+U\+MA node(s) containing pages in the address range is calculated. If all pages in the target have the same policy, it is returned in {\ttfamily policy}. Otherwise, {\ttfamily policy} is set to \hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8a3185bd869b67817fb2bd5164bf360402}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+X\+ED}.

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified, set is considered a nodeset. Otherwise it\textquotesingle{}s a cpuset.

If any other flags are specified, -\/1 is returned and errno is set to E\+I\+N\+V\+AL.

If {\ttfamily len} is 0, -\/1 is returned and errno is set to E\+I\+N\+V\+AL. \mbox{\Hypertarget{a00191_ga537c7508a4e2d1db05673ec5be6e805c}\label{a00191_ga537c7508a4e2d1db05673ec5be6e805c}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+get\+\_\+area\+\_\+memlocation@{hwloc\+\_\+get\+\_\+area\+\_\+memlocation}}
\index{hwloc\+\_\+get\+\_\+area\+\_\+memlocation@{hwloc\+\_\+get\+\_\+area\+\_\+memlocation}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+get\+\_\+area\+\_\+memlocation()}{hwloc\_get\_area\_memlocation()}}
{\footnotesize\ttfamily int hwloc\+\_\+get\+\_\+area\+\_\+memlocation (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{const void $\ast$}]{addr,  }\item[{size\+\_\+t}]{len,  }\item[{\hyperlink{a00205_gaa3c2bf4c776d603dcebbb61b0c923d84}{hwloc\+\_\+bitmap\+\_\+t}}]{set,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Get the N\+U\+MA nodes where memory identified by ({\ttfamily addr}, {\ttfamily len} ) is physically allocated. 

Fills {\ttfamily set} according to the N\+U\+MA nodes where the memory area pages are physically allocated. If no page is actually allocated yet, {\ttfamily set} may be empty.

If pages spread to multiple nodes, it is not specified whether they spread equitably, or whether most of them are on a single node, etc.

The operating system may move memory pages from one processor to another at any time according to their binding, so this function may return something that is already outdated.

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified in {\ttfamily flags}, set is considered a nodeset. Otherwise it\textquotesingle{}s a cpuset.

If {\ttfamily len} is 0, {\ttfamily set} is emptied. \mbox{\Hypertarget{a00191_gae21f0a1a884929c784bebf070252aa56}\label{a00191_gae21f0a1a884929c784bebf070252aa56}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+get\+\_\+membind@{hwloc\+\_\+get\+\_\+membind}}
\index{hwloc\+\_\+get\+\_\+membind@{hwloc\+\_\+get\+\_\+membind}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+get\+\_\+membind()}{hwloc\_get\_membind()}}
{\footnotesize\ttfamily int hwloc\+\_\+get\+\_\+membind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{\hyperlink{a00205_gaa3c2bf4c776d603dcebbb61b0c923d84}{hwloc\+\_\+bitmap\+\_\+t}}]{set,  }\item[{\hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} $\ast$}]{policy,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Query the default memory binding policy and physical locality of the current process or thread. 

This function has two output parameters\+: {\ttfamily set} and {\ttfamily policy}. The values returned in these parameters depend on both the {\ttfamily flags} passed in and the current memory binding policies and nodesets in the queried target.

Passing the \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} flag specifies that the query target is the current policies and nodesets for all the threads in the current process. Passing \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} specifies that the query target is the current policy and nodeset for only the thread invoking this function.

If neither of these flags are passed (which is the most portable method), the process is assumed to be single threaded. This allows hwloc to use either process-\/based OS functions or thread-\/based OS functions, depending on which are available.

\hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} is only meaningful when \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} is also specified. In this case, hwloc will check the default memory policies and nodesets for all threads in the process. If they are not identical, -\/1 is returned and errno is set to E\+X\+D\+EV. If they are identical, the values are returned in {\ttfamily set} and {\ttfamily policy}.

Otherwise, if \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} is specified (and \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} is {\itshape not} specified), the default set from each thread is logically OR\textquotesingle{}ed together. If all threads\textquotesingle{} default policies are the same, {\ttfamily policy} is set to that policy. If they are different, {\ttfamily policy} is set to \hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8a3185bd869b67817fb2bd5164bf360402}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+X\+ED}.

In the \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} case (or when neither \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} or \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} is specified), there is only one set and policy; they are returned in {\ttfamily set} and {\ttfamily policy}, respectively.

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified, set is considered a nodeset. Otherwise it\textquotesingle{}s a cpuset.

If any other flags are specified, -\/1 is returned and errno is set to E\+I\+N\+V\+AL. \mbox{\Hypertarget{a00191_ga1730ceb18ec6ee3b7bd3d0db81f07dc8}\label{a00191_ga1730ceb18ec6ee3b7bd3d0db81f07dc8}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+get\+\_\+proc\+\_\+membind@{hwloc\+\_\+get\+\_\+proc\+\_\+membind}}
\index{hwloc\+\_\+get\+\_\+proc\+\_\+membind@{hwloc\+\_\+get\+\_\+proc\+\_\+membind}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+get\+\_\+proc\+\_\+membind()}{hwloc\_get\_proc\_membind()}}
{\footnotesize\ttfamily int hwloc\+\_\+get\+\_\+proc\+\_\+membind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{hwloc\+\_\+pid\+\_\+t}]{pid,  }\item[{\hyperlink{a00205_gaa3c2bf4c776d603dcebbb61b0c923d84}{hwloc\+\_\+bitmap\+\_\+t}}]{set,  }\item[{\hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t} $\ast$}]{policy,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Query the default memory binding policy and physical locality of the specified process. 

This function has two output parameters\+: {\ttfamily set} and {\ttfamily policy}. The values returned in these parameters depend on both the {\ttfamily flags} passed in and the current memory binding policies and nodesets in the queried target.

Passing the \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} flag specifies that the query target is the current policies and nodesets for all the threads in the specified process. If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} is not specified (which is the most portable method), the process is assumed to be single threaded. This allows hwloc to use either process-\/based OS functions or thread-\/based OS functions, depending on which are available.

Note that it does not make sense to pass \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} to this function.

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+S\+T\+R\+I\+CT} is specified, hwloc will check the default memory policies and nodesets for all threads in the specified process. If they are not identical, -\/1 is returned and errno is set to E\+X\+D\+EV. If they are identical, the values are returned in {\ttfamily set} and {\ttfamily policy}.

Otherwise, {\ttfamily set} is set to the logical OR of all threads\textquotesingle{} default set. If all threads\textquotesingle{} default policies are the same, {\ttfamily policy} is set to that policy. If they are different, {\ttfamily policy} is set to \hyperlink{a00191_ggac9764f79505775d06407b40f5e4661e8a3185bd869b67817fb2bd5164bf360402}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+M\+I\+X\+ED}.

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified, set is considered a nodeset. Otherwise it\textquotesingle{}s a cpuset.

If any other flags are specified, -\/1 is returned and errno is set to E\+I\+N\+V\+AL.

\begin{DoxyNote}{Note}
{\ttfamily hwloc\+\_\+pid\+\_\+t} is {\ttfamily pid\+\_\+t} on Unix platforms, and {\ttfamily H\+A\+N\+D\+LE} on native Windows platforms. 
\end{DoxyNote}
\mbox{\Hypertarget{a00191_gaf881faefe20701229f07dd7dbd0125ed}\label{a00191_gaf881faefe20701229f07dd7dbd0125ed}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+set\+\_\+area\+\_\+membind@{hwloc\+\_\+set\+\_\+area\+\_\+membind}}
\index{hwloc\+\_\+set\+\_\+area\+\_\+membind@{hwloc\+\_\+set\+\_\+area\+\_\+membind}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+set\+\_\+area\+\_\+membind()}{hwloc\_set\_area\_membind()}}
{\footnotesize\ttfamily int hwloc\+\_\+set\+\_\+area\+\_\+membind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{const void $\ast$}]{addr,  }\item[{size\+\_\+t}]{len,  }\item[{\hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t}}]{set,  }\item[{\hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t}}]{policy,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Bind the already-\/allocated memory identified by (addr, len) to the N\+U\+MA node(s) specified by {\ttfamily set}. 

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified, set is considered a nodeset. Otherwise it\textquotesingle{}s a cpuset.

\begin{DoxyReturn}{Returns}
0 if {\ttfamily len} is 0. 

-\/1 with errno set to E\+N\+O\+S\+YS if the action is not supported 

-\/1 with errno set to E\+X\+D\+EV if the binding cannot be enforced 
\end{DoxyReturn}
\mbox{\Hypertarget{a00191_ga020951efa0ce3862bd4faec295501a7f}\label{a00191_ga020951efa0ce3862bd4faec295501a7f}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+set\+\_\+membind@{hwloc\+\_\+set\+\_\+membind}}
\index{hwloc\+\_\+set\+\_\+membind@{hwloc\+\_\+set\+\_\+membind}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+set\+\_\+membind()}{hwloc\_set\_membind()}}
{\footnotesize\ttfamily int hwloc\+\_\+set\+\_\+membind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{\hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t}}]{set,  }\item[{\hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t}}]{policy,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Set the default memory binding policy of the current process or thread to prefer the N\+U\+MA node(s) specified by {\ttfamily set}. 

If neither \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+P\+R\+O\+C\+E\+SS} nor \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+T\+H\+R\+E\+AD} is specified, the current process is assumed to be single-\/threaded. This is the most portable form as it permits hwloc to use either process-\/based OS functions or thread-\/based OS functions, depending on which are available.

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified, set is considered a nodeset. Otherwise it\textquotesingle{}s a cpuset.

\begin{DoxyReturn}{Returns}
-\/1 with errno set to E\+N\+O\+S\+YS if the action is not supported 

-\/1 with errno set to E\+X\+D\+EV if the binding cannot be enforced 
\end{DoxyReturn}
\mbox{\Hypertarget{a00191_gabc91ff16f7e41047924e3a4ae6d9da7e}\label{a00191_gabc91ff16f7e41047924e3a4ae6d9da7e}} 
\index{Memory binding@{Memory binding}!hwloc\+\_\+set\+\_\+proc\+\_\+membind@{hwloc\+\_\+set\+\_\+proc\+\_\+membind}}
\index{hwloc\+\_\+set\+\_\+proc\+\_\+membind@{hwloc\+\_\+set\+\_\+proc\+\_\+membind}!Memory binding@{Memory binding}}
\subsubsection{\texorpdfstring{hwloc\+\_\+set\+\_\+proc\+\_\+membind()}{hwloc\_set\_proc\_membind()}}
{\footnotesize\ttfamily int hwloc\+\_\+set\+\_\+proc\+\_\+membind (\begin{DoxyParamCaption}\item[{\hyperlink{a00186_ga9d1e76ee15a7dee158b786c30b6a6e38}{hwloc\+\_\+topology\+\_\+t}}]{topology,  }\item[{hwloc\+\_\+pid\+\_\+t}]{pid,  }\item[{\hyperlink{a00205_gae991a108af01d408be2776c5b2c467b2}{hwloc\+\_\+const\+\_\+bitmap\+\_\+t}}]{set,  }\item[{\hyperlink{a00191_gac9764f79505775d06407b40f5e4661e8}{hwloc\+\_\+membind\+\_\+policy\+\_\+t}}]{policy,  }\item[{int}]{flags }\end{DoxyParamCaption})}



Set the default memory binding policy of the specified process to prefer the N\+U\+MA node(s) specified by {\ttfamily set}. 

If \hyperlink{a00191_ggab00475fd98815bf4fb9aaf752030e7d2a71f19fe4505f1c083dc8e6f7bdea6256}{H\+W\+L\+O\+C\+\_\+\+M\+E\+M\+B\+I\+N\+D\+\_\+\+B\+Y\+N\+O\+D\+E\+S\+ET} is specified, set is considered a nodeset. Otherwise it\textquotesingle{}s a cpuset.

\begin{DoxyReturn}{Returns}
-\/1 with errno set to E\+N\+O\+S\+YS if the action is not supported 

-\/1 with errno set to E\+X\+D\+EV if the binding cannot be enforced
\end{DoxyReturn}
\begin{DoxyNote}{Note}
{\ttfamily hwloc\+\_\+pid\+\_\+t} is {\ttfamily pid\+\_\+t} on Unix platforms, and {\ttfamily H\+A\+N\+D\+LE} on native Windows platforms. 
\end{DoxyNote}
