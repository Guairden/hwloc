

hwloc is organized in components that are responsible for discovering objects. Depending on the topology configuration, some components will be used, some will be ignored. The usual default is to enable the native operating system component, (e.\+g. {\ttfamily linux} or {\ttfamily solaris}) and the {\ttfamily pci} miscellaneous component. If available, an architecture-\/specific component (such as {\ttfamily x86}) may also improve the topology detection.

If a X\+ML topology is loaded, the {\ttfamily xml} discovery component will be used instead of all other components. It internally uses a specific class of components for the actual X\+ML import/export routines ({\ttfamily xml\+\_\+libxml} and {\ttfamily xml\+\_\+nolibxml}) but these will not be discussed here (see \hyperlink{a00388_xml_backends}{libxml2 and minimalistic X\+ML backends}).

 \hypertarget{a00392_plugins_default}{}\section{Components enabled by default}\label{a00392_plugins_default}
The hwloc core contains a list of components sorted by priority. Each one is enabled as long as it does not conflict with the previously enabled ones. This includes native operating system components, architecture-\/specific ones, and if available, I/O components such as {\ttfamily pci}.

Usually the native operating system component (when it exists, e.\+g. {\ttfamily linux} or {\ttfamily aix}) is enabled first. Then hwloc looks for an architecture specific component (e.\+g. {\ttfamily x86}). Finally there also exist a basic component ({\ttfamily no\+\_\+os}) that just tries to discover the number of P\+Us in the system.

Each component discovers as much topology information as possible. Most of them, including most native OS components, do nothing unless the topology is still empty. Some others, such as {\ttfamily x86} and {\ttfamily pci}, can complete and annotate what other backends found earlier. Discovery is performed by phases\+: C\+P\+Us are first discovered, then memory is attached, then P\+CI, etc.

Default priorities ensure that clever components are invoked first. Native operating system components have higher priorities, and are therefore invoked first, because they likely offer very detailed topology information. If needed, it will be later extended by architecture-\/specific information (e.\+g. from the {\ttfamily x86} component).

If any configuration function such as \hyperlink{a00192_ga879439b7ee99407ee911b3ac64e9a25e}{hwloc\+\_\+topology\+\_\+set\+\_\+xml()} is used before loading the topology, the corresponding component is enabled first. Then, as usual, hwloc enables any other component (based on priorities) that does not conflict.

Certain components that manage a virtual topology, for instance X\+ML topology import or synthetic topology description, conflict with all other components. Therefore, one of them may only be loaded (e.\+g. with {\ttfamily \hyperlink{a00192_ga879439b7ee99407ee911b3ac64e9a25e}{hwloc\+\_\+topology\+\_\+set\+\_\+xml()}}) if no other component is enabled.

The environment variable {\ttfamily H\+W\+L\+O\+C\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+S\+\_\+\+V\+E\+R\+B\+O\+SE} may be set to get verbose messages about component registration (including their priority) and enabling.

 \hypertarget{a00392_plugins_select}{}\section{Selecting which components to use}\label{a00392_plugins_select}
If no topology configuration functions such as {\ttfamily \hyperlink{a00192_ga4fab186bb6181a00bcf585825fddd38d}{hwloc\+\_\+topology\+\_\+set\+\_\+synthetic()}} have been called, plugins may be selected with environment variables such as {\ttfamily H\+W\+L\+O\+C\+\_\+\+X\+M\+L\+F\+I\+LE}, {\ttfamily H\+W\+L\+O\+C\+\_\+\+S\+Y\+N\+T\+H\+E\+T\+IC}, {\ttfamily H\+W\+L\+O\+C\+\_\+\+F\+S\+R\+O\+OT}, or {\ttfamily H\+W\+L\+O\+C\+\_\+\+C\+P\+U\+I\+D\+\_\+\+P\+A\+TH} (see \hyperlink{a00382}{Environment Variables}).

Finally, the environment variable {\ttfamily H\+W\+L\+O\+C\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+TS} resets the list of selected components. If the variable is set and empty (or set to a single comma separating nothing, since some operating systems do not accept empty variables), the normal plugin priority order is used.

If the variable is set to {\ttfamily x86} in this variable will cause the {\ttfamily x86} component to take precedence over any other component, including the native operating system component. It is therefore loaded first, before hwloc tries to load all remaining non-\/conflicting components. In this case, {\ttfamily x86} would take care of discovering everything it supports, instead of only completing what the native OS information. This may be useful if the native component is buggy on some platforms.

It is possible to prevent some components from being loaded by prefixing their name with {\ttfamily -\/} in the list. For instance {\ttfamily x86,-\/pci} will load the {\ttfamily x86} component, then let hwloc load all the usual components except {\ttfamily pci}. A single component phase may also be blacklisted, for instance with {\ttfamily -\/linux\+:io}. \hyperlink{a00192_ga9ad41adf418cee1c0ee32ba9bd4a3d36}{hwloc\+\_\+topology\+\_\+set\+\_\+components()} may also be used inside the program to prevent the loading of a specific component (or phases) for the target topology.

It is possible to prevent all remaining components from being loaded by placing {\ttfamily stop} in the environment variable. Only the components listed before this keyword will be enabled.

 \hypertarget{a00392_plugins_load}{}\section{Loading components from plugins}\label{a00392_plugins_load}
Components may optionally be built as plugins so that the hwloc core library does not directly depend on their dependencies (for instance the {\ttfamily libpciaccess} library). Plugin support may be enabled with the {\ttfamily -\/-\/enable-\/plugins} configure option. All components buildable as plugins will then be built as plugins. The configure option may be given a comma-\/separated list of component names to specify the exact list of components to build as plugins.

Plugins are built as independent dynamic libraries that are installed in {\ttfamily \$libdir/hwloc}. All plugins found in this directory are loaded during {\ttfamily topology\+\_\+init()} (unless blacklisted in {\ttfamily H\+W\+L\+O\+C\+\_\+\+P\+L\+U\+G\+I\+N\+S\+\_\+\+B\+L\+A\+C\+K\+L\+I\+ST}, see \hyperlink{a00382}{Environment Variables}). A specific list of directories (colon-\/separated) to scan may be specified in the {\ttfamily H\+W\+L\+O\+C\+\_\+\+P\+L\+U\+G\+I\+N\+S\+\_\+\+P\+A\+TH} environment variable.

Note that loading a plugin just means that the corresponding component is registered to the hwloc core. Components are then only enabled if the topology configuration requests it, as explained in the previous sections.

Also note that plugins should carefully be enabled and used when embedding hwloc in another project, see \hyperlink{a00393}{Embedding hwloc in Other Software} for details.

 \hypertarget{a00392_plugins_list}{}\section{Existing components and plugins}\label{a00392_plugins_list}
All components distributed within hwloc are listed below. The list of actually available components may be listed at running with the {\ttfamily H\+W\+L\+O\+C\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+S\+\_\+\+V\+E\+R\+B\+O\+SE} environment variable (see \hyperlink{a00382}{Environment Variables}).


\begin{DoxyDescription}
\item[linux ]The official component for discovering C\+PU, memory and I/O devices on Linux. It discovers P\+CI devices without the help of external libraries such as libpciaccess, but requires the pci component for adding vendor/device names to P\+CI objects. It also discovers many kinds of Linux-\/specific OS devices.  
\item[aix, darwin, freebsd, hpux, netbsd, solaris, windows ]Each officially supported operating system has its own native component, which is statically built when supported, and which is used by default.  
\item[x86 ]The x86 architecture (either 32 or 64 bits) has its own component that may complete or replace the previously-\/found C\+PU information. It is statically built when supported.  
\item[bgq ]This component is specific to I\+BM Blue\+Gene/Q compute node (running C\+NK). It is built and enabled by default when {\ttfamily -\/-\/host=powerpc64-\/bgq-\/linux} is passed to configure (see \hyperlink{a00394_faq_bgq}{How do I build hwloc for Blue\+Gene/Q?}).  
\item[no\+\_\+os ]A basic component that just tries to detect the number of processing units in the system. It mostly serves on operating systems that are not natively supported. It is always statically built.  
\item[pci ]P\+CI object discovery uses the external pciaccess library (aka libpciaccess); see \hyperlink{a00384}{I/O Devices}. It may also annotate existing P\+CI devices with vendor and device names. {\bfseries It may be built as a plugin}.  
\item[opencl ]The Open\+CL component creates co-\/processor OS device objects such as {\itshape opencl0d0} (first device of the first Open\+CL platform) or {\itshape opencl1d3} (fourth device of the second platform). Only the A\+MD and N\+V\+I\+D\+IA Open\+CL implementations currently offer locality information. {\bfseries It may be built as a plugin}.  
\item[rsmi ]This component creates G\+PU OS device objects such as {\itshape rsmi0} for describing A\+MD G\+P\+Us. {\bfseries It may be built as a plugin}.  
\item[cuda ]This component creates co-\/processor OS device objects such as {\itshape cuda0} that correspond to N\+V\+I\+D\+IA G\+P\+Us used with C\+U\+DA library. {\bfseries It may be built as a plugin}.  
\item[nvml ]Probing the N\+V\+I\+D\+IA Management Library creates OS device objects such as {\itshape nvml0} that are useful for batch schedulers. It also detects the actual P\+C\+Ie link bandwidth without depending on power management state and without requiring administrator privileges. {\bfseries It may be built as a plugin}.  
\item[gl ]Probing the N\+V-\/\+C\+O\+N\+T\+R\+OL X extension (N\+V\+Ctrl library) creates OS device objects such as {\itshape \+:0.\+0} corresponding to N\+V\+I\+D\+IA displays. They are useful for graphical applications that need to place computation and/or data near a rendering G\+PU. {\bfseries It may be built as a plugin}.  
\item[synthetic ]Synthetic topology support (see \hyperlink{a00389}{Synthetic topologies}) is always built statically.  
\item[xml ]X\+ML topology import (see \hyperlink{a00388}{Importing and exporting topologies from/to X\+ML files}) is always built statically. It internally uses one of the X\+ML backends (see \hyperlink{a00388_xml_backends}{libxml2 and minimalistic X\+ML backends}). 
\begin{DoxyItemize}
\item {\bfseries xml\+\_\+nolibxml} is a basic and hwloc-\/specific X\+ML import/export. It is always statically built.  
\item {\bfseries xml\+\_\+libxml} relies on the external libxml2 library for provinding a feature-\/complete X\+ML import/export. {\bfseries It may be built as a plugin}.   
\end{DoxyItemize}
\item[fake ]A dummy plugin that does nothing but is used for debugging plugin support.  
\end{DoxyDescription}